<html>
<head><title>РОЛ / Справочная информация</title>
<link href="/index.css" rel="stylesheet" type="text/css">
<script language="JavaScript" src="/script.js"></script>
<script language="JavaScript">
function menuover(obj)
{
obj.style.backgroundColor="#ececec";
obj.all.tags('A').item(0).style.color="#000000";
}

function menuout(obj)
{
obj.style.backgroundColor="#ffffff";
obj.all.tags('A').item(0).style.color="#018977";
}

function menuclick(obj)
{
window.location.href=obj.all.tags('A').item(0).href;
}

function doView (target,file) {
var w=window.open(file + '?url=' + location.href, target,
  'isRaised=yes,toolbar=no,scrollbars=yes,resizable=yes,alwaysRaised=yes,width=515,height=310'
);
return false;
}           
</script>

<style>
hr {  height: 1px}
</style>
</head>
<body leftmargin=0 rightmargin=0 topmargin=0 marginheight=0 marginwidth=0 bgcolor="#FFFFFF">
<table width=100% border=0 cellspacing=0 cellpadding=0>
<tr> 
	<td width=6 valign=top><img src="/images/header_fon2.gif" width=6 height="40"></td>
	<td>
<span style="z-index:1; visibility:hidden; position:absolute;">
<!--begin of Top100-->

	<a href="http://top100.rambler.ru/top100/"><img src="http://counter.rambler.ru/top100.cnt?265968" width=1 height=1 border=0></a>

<img src=http://stat.stars.ru/cgi-bin/s border=0>
</span>

<table id=header1 width="100%" cellpadding=0 cellspacing=0 border=0 align=center background=/p.gif>
<tr background="/images/header_fon.gif">
	<td valign="bottom" align=right width="151" background="/images/header_fon.gif"><FONT class=date>






	
	







18 июля 2004 года
</font>&nbsp;&nbsp;&nbsp;<br><img src="/images/p.gif" width=6 height=3><br>
<div align=left><img src="/images/header_rol.gif" usemap="#Map2" border=0 width="151"></div></td>
    <td background="/images/header_sfon.gif" width="8"><img src="/images/header_l.gif" width="8" height="40"></td>
	<td background="/images/header_sfon.gif" align=center width="140"><img src="/images/p.gif" width=6 height="10"><br>

<a href=http://stat.rol.ru/GOAD/txt_toolbar/services.rol.ru/rus/ class="rol"><img src="/images/header_pic1.gif" width="10" height="10" border=0><br>Доступ в Интернет</a></td>

    <td background="/images/header_sfon.gif" align=center width="120"><img src="/images/p.gif" width=6 height="10"><br><a href=http://postcard.rol.ru class="rol"><img src="/images/header_pic1.gif" width="10" height="10" border=0><br>Открытки</a></td>

    <td background="/images/header_sfon.gif" align=center width="93"><img src="/images/p.gif" width=6 height="10"><br><a href=http://www.aport.ru class="rol"><img src="/images/header_pic1.gif" width="10" height="10" border=0><br>Поиск</a></td>
	<td background="/images/header_sfon.gif" align=center width="115"><img src="/images/p.gif" width=6 height="10"><br><a href=http://omen.ru/LOVE.HTM class="rol"><img src="/images/header_pic1.gif" width="10" height="10" border=0><br>Знакомства</a></td>
    <td background="/images/header_sfon.gif" align=center width="70"><img src="/images/p.gif" width=6 height="10"><br><a href=http://ag.ru/ class="rol"><img src="/images/header_pic1.gif" width="10" height="10" border=0><br>Игры</a></td>
    <td background="/images/header_sfon.gif" align=center width="112"><img src="/images/p.gif" width=6 height="10"><br><a href=http://referat.rol.ru class="rol"><img src="/images/header_pic1.gif" width="10" height="10" border=0><br>Рефераты</a></td>
    <td background="/images/header_sfon.gif" align=center width="135" nowrap><img src="/images/p.gif" width=6 height="10"><br><a href=http://voffice.rol.ru class="rol"><img src="/images/header_pic1.gif" width="10" height="10" border=0><br><nobr>Личный кабинет</nobr></a></td>
    <td background="/images/header_sfon_bg.gif" width="8" align=right><img src="/images/header_r.gif" width="8" height="40"></td>
    <td width="21" background="/images/header_end_bg.gif"><a href="mailto:info@rol.ru"><img src="/images/header_end.gif" width="21" height="40" border=0 alt="Служба поддержки"></a></td>
</tr>
</table><map name="Map2">
<area shape="rect" coords="14,3,443,19" href="/">
</map>


<img src=/p.gif width=6 height=2><br>
<table width=100% border=0 cellspacing=0 cellpadding=1 bgcolor=eeeadb><tr> 
<td width=260 align=center valign=top bgcolor=eeeadb><img src="/images/rol3l_pic.gif" width="30" height="26"><img src="/images/tit_news.gif" width="155" height="26" alt="Новости"><br>
<table width=100 border=0 cellspacing=0 cellpadding=0 bgcolor="#000000"><tr><td>
<table border=0 cellspacing=1 cellpadding=0 bordercolor="#464646" bgcolor="#464646" width="250">
<tr align=center bgcolor=eeeadb> 
<td colspan=3><a href="http://www.krugosvet.ru/" class=menu>Энциклопедия "Кругосвет"</a></td>
</tr><tr align=center bgcolor=eeeadb> 
<td nowrap>&nbsp;<a href="http://scripts.online.ru/cgi-bin/dates/date.cgi?rol=1" class=menu>Даты дня</a>&nbsp;</td>
<td>&nbsp;&nbsp;<a href="/weather/weather.htm" class=menu>Погода</a>&nbsp;&nbsp;</td>
<td>&nbsp;<a href="http://catalog.aport.ru/rus/themes.asp?id=294" class=menu>Справочники</a>&nbsp;</td>
</tr></table>
</td></tr></table><img src=/p.gif width=260 height=1>
</td><td align=right bgcolor=eeeadb><img src="/images/tmp_banner468x60.gif" width="468" height="60"></td>
</tr></table><img src=/p.gif width=6 height=2><br>

<table width=100% border=0 cellspacing=0 cellpadding=0><tr>
<td height=6><img src=/p.gif width=6 height=6></td>
</tr><tr><td valign=top bgcolor="#000000"> 

<table width=100% border=0 cellspacing=1 cellpadding=0 bgcolor="#464646" height=100%><tr>
<td bgcolor="#FFFFFF" valign=top> 

<table width=100% border=0 cellspacing=0 cellpadding=5 height=100%><tr>
<td bgcolor="#FFFFFF" valign=top> 
<!-- begin main text -->



<DIV class=head><A href="http://www.w3.org/"><IMG alt=W3C height=48 src="w3c_home.png" width=72></A> 

<H1>Язык XML Path (XPath)<BR>версия 1.0</H1>

<H2>Рекомендация W3C от 16 ноября 1999 года</H2>

</DIV>

<table width="100%" cellpadding="0"><tr><td bgcolor="#E8E8E8">

Данный документ представляет собой перевод спецификации XML Path Language (XPath) Version 1.0 (W3C Recommendation) на русский язык. При этом нормативным документом считается оригинальная спецификация на английском языке, которую можно найти по адресу 

<DIR>

<A href="http://www.w3.org/TR/1999/REC-xpath-19991116">http://www.w3.org/TR/1999/REC-xpath-19991116</A>.

</DIR>

Перевод спецификации на русский язык представлен на страницах портала "Россия-Он-Лайн":

<DIR>

<A href="http://www.rol.ru/news/it/helpdesk/xpath01.htm">http://www.rol.ru/news/it/helpdesk/xpath01.htm</A>

</DIR>

Перевод выполнен <A href="mailto:radik_u@mail.ru">Радиком Усмановым</A>, <A href="http://www.luxoft.com">Luxoft</A> (<A href="http://www.ibs.ru">IBS</A>)<BR>

Представленный документ может содержать ошибки перевода.

</td></tr></table>

<DL>

<DT>Данная версия: 

<DD><A href="http://www.w3.org/TR/1999/REC-xpath-19991116">http://www.w3.org/TR/1999/REC-xpath-19991116</A><BR>

(доступна в форматах <A href="http://www.w3.org/TR/1999/REC-xpath-19991116.xml">XML</A> и <A href="http://www.w3.org/TR/1999/REC-xpath-19991116.html">HTML</A>) 

<DT>Последняя версия: 

<DD><A href="http://www.w3.org/TR/xpath">http://www.w3.org/TR/xpath</A> <BR>

<DT>Предыдущие версии: 

<DD><A href="http://www.w3.org/TR/1999/PR-xpath-19991008">http://www.w3.org/TR/1999/PR-xpath-19991008</A><BR>

<A href="http://www.w3.org/1999/08/WD-xpath-19990813">http://www.w3.org/1999/08/WD-xpath-19990813</A><BR>

<A href="http://www.w3.org/1999/07/WD-xpath-19990709">http://www.w3.org/1999/07/WD-xpath-19990709</A><BR>

<A href="http://www.w3.org/TR/1999/WD-xslt-19990421">http://www.w3.org/TR/1999/WD-xslt-19990421</A><BR>

<DT>Редакторы: 

<DD>James Clark <a href="mailto:jjc@jclark.com">&lt;jjc@jclark.com&gt;</a><BR>

Steve DeRose (Inso Corp. и Brown University) <a href="mailto:Steven_DeRose@Brown.edu">&lt;Steven_DeRose@Brown.edu&gt;</a><BR>

</DD></DL>

<P class=copyright><A href="http://www.w3.org/Consortium/Legal/ipr-notice.html#Copyright">Copyright</A> &nbsp;&copy;&nbsp; 1999 <A href="http://www.w3.org/">W3C</A><SUP>&reg;</SUP> (<A href="http://www.lcs.mit.edu/">MIT</A>, <A href="http://www.inria.fr/">INRIA</A>, <A href="http://www.keio.ac.jp/">Keio</A>). Все права защищены. Документ подчиняется правилам W3C, касающимся <A href="http://www.w3.org/Consortium/Legal/ipr-notice.html#Legal_Disclaimer">ответственности</A>, <A href="http://www.w3.org/Consortium/Legal/ipr-notice.html#W3C_Trademarks">торговой марки</A>, <A href="http://www.w3.org/Consortium/Legal/copyright-documents.html">использования документов</A> и <A href="http://www.w3.org/Consortium/Legal/copyright-software.html">лицензирования программного обеспечения</A>.</P>

<HR title="Separator for header">

<H2><A name=abstract>Аннотация</A></H2>

<P>XPath - это язык адресации частей XML документа, предназначенный для использования с XSLT и Xpointer.</P>

<H2><A name=status>Статус этого документа</A> </H2>

<P>Данный документ был рассмотрен членами W3C и другими заинтересованными сторонами и утвержден Директором в качестве <A href="http://www.w3.org/Consortium/Process/#RecsW3C">Рекомендации</A> W3C. Данный документ является окончательным и может быть использован для ссылок и цитирования в других материалах в качестве нормативного документа. Участие организации W3C в разработке данной Рекомендации заключается в привлечении внимания к представленной спецификации и содействии ее широкому распространению. Результатом этой деятельности является повышение функциональности и универсальности Сети.</P>

<P>Перечень ошибок, выявленных в данной спецификации, доступен по адресу <A href="http://www.w3.org/1999/11/REC-xpath-19991116-errata">http://www.w3.org/1999/11/REC-xpath-19991116-errata</A>.</P>


<P>Комментарии к этой спецификации можно отправлять по адресу <A href="mailto:www-xpath-comments@w3.org">www-xpath-comments@w3.org</A>, доступен <A href="http://lists.w3.org/Archives/Public/www-xpath-comments">архив</A> комментариев.</P>

<P>Несмотря на то, что нормативную силу имеет только английская версия данной спецификации, по адресу <A href="http://www.w3.org/Style/XSL/translations.html">http://www.w3.org/Style/XSL/translations.html</A> можно обнаружить ее перевод на другие языки.</P>

<P>По адресу <A href="http://www.w3.org/TR">http://www.w3.org/TR</A> можно найти перечень текущих Рекомендаций W3C и другие технические материалы.</P>

<P>Данная спецификация является совместным результатом деятельности рабочих групп XSL и XML Linking, а потому является частью сразу двух проектов <A href="http://www.w3.org/Style/Activity">W3C Style activity</A> и <A href="http://www.w3.org/XML/Activity">W3C XML activity</A>.</P>

<H2><A name=contents>Содержание</A></H2>

1 <A href="#section-Introduction">Введение</A> <BR>

2 <A href="#location-paths">Пути адресации</A><BR>

&nbsp;&nbsp;&nbsp;&nbsp;2.1 <A href="#section-Location-Steps">Шаги адресации</A><BR>

&nbsp;&nbsp;&nbsp;&nbsp;2.2 <A href="#axes">Оси</A><BR>

&nbsp;&nbsp;&nbsp;&nbsp;2.3 <A href="#node-tests">Проверка узлов</A><BR>

&nbsp;&nbsp;&nbsp;&nbsp;2.4 <A 
href="#predicates">Предикаты</A><BR>

&nbsp;&nbsp;&nbsp;&nbsp;2.5 <A href="#path-abbrev">Сокращенный синтаксис</A><BR>

3 <A href="#section-Expressions">Выражения</A><BR>

&nbsp;&nbsp;&nbsp;&nbsp;3.1 <A href="#section-Basics">Основы</A><BR>

&nbsp;&nbsp;&nbsp;&nbsp;3.2 <A href="#section-Function-Calls">Вызовы функций</A><BR>

&nbsp;&nbsp;&nbsp;&nbsp;3.3 <A href="#node-sets">Наборы узлов</A><BR>

&nbsp;&nbsp;&nbsp;&nbsp;3.4 <A href="#booleans">Булевы значения</A><BR>

&nbsp;&nbsp;&nbsp;&nbsp;3.5 <A href="#numbers">Числа</A><BR>

&nbsp;&nbsp;&nbsp;&nbsp;3.6 <A href="#strings">Строки</A><BR>

&nbsp;&nbsp;&nbsp;&nbsp;3.7 <A href="#exprlex">Лексическая структура</A><BR>

4 <A href="#corelib">Основная библиотека функций</A><BR>

&nbsp;&nbsp;&nbsp;&nbsp;4.1 <A href="#section-Node-Set-Functions">Функции обработки набора узлов</A><BR>

&nbsp;&nbsp;&nbsp;&nbsp;4.2 <A href="#section-String-Functions">Функции обработки строк</A><BR>

&nbsp;&nbsp;&nbsp;&nbsp;4.3 <A href="#section-Boolean-Functions">Функции обработки булевых значений</A><BR>


&nbsp;&nbsp;&nbsp;&nbsp;4.4 <A href="#section-Number-Functions">Функции обработки чисел</A><BR>

5 <A href="#data-model">Модель данных</A><BR>

&nbsp;&nbsp;&nbsp;&nbsp;5.1 <A href="#root-node">Корневой узел</A><BR>

&nbsp;&nbsp;&nbsp;&nbsp;5.2 <A href="#element-nodes">Узлы элементов</A><BR>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.1 <A href="#unique-id">Уникальные ID</A><BR>

&nbsp;&nbsp;&nbsp;&nbsp;5.3 <A href="#attribute-nodes">Узлы атрибутов</A><BR>

&nbsp;&nbsp;&nbsp;&nbsp;5.4 <A href="#namespace-nodes">Узлы пространства имен</A><BR>

&nbsp;&nbsp;&nbsp;&nbsp;5.5 <A href="#section-Processing-Instruction-Nodes">Узлы инструкций обработки</A><BR>

&nbsp;&nbsp;&nbsp;&nbsp;5.6 <A href="#section-Comment-Nodes">Узлы комментариев</A><BR>

&nbsp;&nbsp;&nbsp;&nbsp;5.7 <A href="#section-Text-Nodes">Текстовые узлы</A> <BR>

6 <A href="#section-Conformance">Соответствие</A><BR>

<H3>Приложения</H3>

A <A href="#section-References">Ссылки</A><BR>

&nbsp;&nbsp;&nbsp;&nbsp;A.1 <A href="#section-Normative-References">Нормативные ссылки</A><BR>

&nbsp;&nbsp;&nbsp;&nbsp;A.2 <A href="#section-Other-References">Остальные ссылки</A><BR>

B <A href="#infoset">Составление информационного набора XML</A> (Обсуждение спецификации)<BR>

<table width="100%" cellpadding="0"><tr><td bgcolor="#E8E8E8"> C <A href="#dictionary">Словарь</A> (Обсуждение спецификации)</td></tr></table>

<BR>

<HR>

<H2><A name=section-Introduction></A>1 Введение</H2>

<P>Язык XPath является результатом попыток создать единые синтаксис и семантику для функционала, совместно используемого XSL Transformations <A href="#XSLT">[XSLT]</A> и XPointer <A href="#XPTR">[XPointer]</A>. Главная задача языка XPath - адресация частей в XML документе <A href="#XML">[XML]</A>. Для достижения этой цели язык дополнительно наделен основными функциями для манипулирования строками, числами и булевыми значениями. В XPath используется компактный синтаксис, отличный от принятого в XML, облегчающий использование языка XPath при записи адресов URI и значений атрибутов XML. XPath работает не с внешним синтаксисом XML документа, а с его абстрактной логической структурой. XPath получил такое название потому, что использовался в URL для записи путей, обеспечивающих навигацию по иерархической структуре XML документа.</P>

<P>Язык XPath спроектирован так, что помимо поддержки адресации он обладает естественным набором элементов, которые могут использоваться для сравнения (проверки, соответствует ли узел некому шаблону). Такой порядок использования языка XPath описывается в спецификации <A href="http://www.w3.org/TR/WD-xslt#patterns">XSLT</A>.</P>

<P>XPath представляет XML документ в виде дерева узлов. Узлы бывают различных типов, например, узлы элементов, узлы атрибутов и узлы текста. Для каждого типа узлов в XPath определяется способ вычисления <A href="#dt-string-value">строкового значения</A>. Некоторые типы узлов имеют также имя. XPath полностью поддерживает пространства имен XML <A href="#XMLNAMES">[XML Names]</A>. В результате, имя любого узла в этом языке образуется из двух частей: локальной части и URI некого пространства имен (возможно, нулевого), такая комбинация называется <A href="#dt-expanded-name">расширенным именем</A>. Указанная модель данных подробно описана в главе <A href="#data-model">[<B>5 Модель данных</B>]</A>.</P>

<P>Главной синтаксической конструкцией языка XPath является выражение. Любое выражение соответствует сценарию <A href="#NT-Expr">Expr</A>. В результате обработки выражения получается объект, относящийся к одному из четырех основных типов:</P>

<UL>

<LI>набор узлов (node-set) - неупорядоченный набор узлов без дубликатов 

<LI>булево значение (boolean) - true или false

<LI>число (number) - число с плавающей точкой

<LI>строка (string) - последовательность UCS символов</LI>

</UL>

<P>Обработка выражений осуществляется, отталкиваясь от некого контекста. В спецификациях XSLT и XPointer указывается, каким образом в XSLT и XPointer, соответственно, определяется контекст для выражений XPath. Контекст образуется из:</P>

<UL>

<LI>узла (<A name=dt-context-node></A><B>узел контекста</B>, context node) 

<LI>пары ненулевых положительных целых чисел (<A name=dt-context-position></A><B>положение в контексте</B> и <A name=dt-context-size></A><B>размер контекста</B>) 


<LI>привязки переменных контекста (variable bindings)

<LI>библиотеки функций

<LI>набора деклараций пространства имен в области видимости данного выражения</LI>

</UL>

<P>Положение в контексте всегда меньше или равно размеру контекста.</P>

<P>Схема привязки переменных контекста образуется в результате отображения множества имен переменных на множество значений переменных. Значением переменной является объект, относящийся к одному из типов, допустимых для значений выражений, либо к какому-либо дополнительному типу, не описанному в спецификации.</P>

<P>Библиотека функций образуется в результате отображения множества названий функций на множество функций. Каждая функция имеет нуль или более аргументов и возвращает один результат. В данном документе описывается основная библиотека функций, которую должны поддерживать все реализации XPath (см. <A href="#corelib">[<B>4 Основная библиотека функций</B>]</A>). Для любой функции в основной библиотеке и аргументы, и результат выполнения относятся к четырем основным типам. И XSLT, и XPointer дополняют XPath, определяя дополнительные функции, часть новых функций оперирует с четырьмя основными типами, остальные - дополнительными типами данных, определенными в XSLT и XPointer.</P>

<P>Декларации пространства имен образуются в результате отображения множества префиксов на множество идентификаторов URI пространств имен.</P>

<P>Привязка переменных контекста, библиотека функций и декларации пространства имен используются для обработки отдельных частей выражения и остаются неизменными на протяжении обработки всего выражения. Узел контекста, размер контекста и положение в контексте, используемые для обработки частей выражения, иногда могут отличаться от используемых для обработки выражения в целом. Некоторые типы выражений меняют текущий узел контекста, однако размер контекста и положение в контексте могут менять только предикаты (см. <A href="#predicates">[<B>2.4 Предикаты</B>]</A>). Если описывается обработка некоторого типа выражений, то всегда явно указывается, когда для обработки частей выражения используется другой узел контекста, измененные размер контекста или положение в контексте. Если же об узле контекста, размере контекста или положении в контексте в описании ничего не сказано, считается, что они остаются неизменными в ходе обработки всех подвыражений в выражении указанного типа.</P>

<P>Выражения XPath часто используются в атрибутах XML. Описываемая в этой главе грамматика примеряется к значению атрибута после выполнения нормализации, описанной в XML 1.0. Так, если, к примеру, в грамматике используется символ <CODE>&lt;</CODE>, то в исходном XML документе его нельзя записывать просто как <CODE>&lt;</CODE>. Вместо этого, согласно правилам XML 1.0, его необходимо маскировать, например, записав как <CODE>&amp;lt;</CODE>. Строковые значения, используемые в выражениях, заключаются в одинарные или двойные кавычки, которые используются также для записи атрибутов XML. Поэтому, чтобы символ кавычки в этом выражении не интерпретировался XML процессором как конец значения атрибута, его необходимо записывать как ссылку на символ (<CODE>&amp;quot;</CODE> или <CODE>&amp;apos;</CODE>). Впрочем, если атрибут XML был заключен в двойные кавычки, в выражении можно свободно использовать символы одинарных кавычек, и наоборот.</P>

<P>Другим важным типом выражений является путь адресации (location path). Путь адресации выбирает некое множество узлов, отталкиваясь от некоторого узла контекста. Результатом обработки выражения, соответствующего пути адресации, является множество узлов, собранных согласно этому пути. Путь адресации может рекурсивно содержать выражения, используемые для фильтрации наборов узлов. Путь адресации соответствует сценарию <A href="#NT-LocationPath">LocationPath</A>.</P>

<P>В представленной далее грамматике используются незавершенные конструктивы <A href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A> и <A href="http://www.w3.org/TR/REC-xml-names#NT-NCName">NCName</A>, описанные в <A href="#XMLNAMES">[XML Names]</A>, а также пробельный символ <A href="http://www.w3.org/TR/REC-xml#NT-S">S</A>, описанный в <A href="#XML">[XML]</A>. Грамматика использует ту же самую нотацию EBNF, что <A href="#XML">[XML]</A> (за исключением того, что названия грамматических конструкций всегда пишутся с заглавной буквы).</P>


<P>Обработка выражения начинается с его разбиения на строки символов, подлежащих преобразованию в лексемы. Затем идет разбор полученной последовательности лексем. В промежутки между лексемами могут свободно ставиться пробельные символы. Процесс преобразования в лексемы (tokenization) описан в главе <A href="#exprlex">[<B>3.7 Лексическая структура</B>]</A>.</P>

<H2><A name=location-paths></A>2 Пути адресации</H2>

<P>Хотя пути адресации (location path) и не являются самой главной грамматической конструкцией языка (<A href="#NT-LocationPath">LocationPath</A> - это частный случай <A href="#NT-Expr">Expr</A>), они имеют самое большое значение, а потому будут описаны в первую очередь.</P>

<P>Каждый путь адресации может быть описан с помощью простого, но довольно громоздкого синтаксиса. Существует также ряд синтаксических аббревиатур для краткого обозначения основных случаев. Сперва в этой главе с помощью развернутого синтаксиса будет дано разъяснение семантики путей адресации. Затем будет показано, каким образом сокращенный синтаксис приводится к развернутому (см. <A href="#path-abbrev">[<B>2.5 Сокращенный синтаксис</B>]</A>).</P>

<P>Ниже приводятся некоторые примеры путей адресации, использующих развернутый синтаксис:</P>

<UL>

<LI><P><CODE>child::para</CODE> находит элемент <CODE>para</CODE>, являющийся непосредственным потомком узла контекста</P>

<LI><P><CODE>child::*</CODE> собирает все элементы, являющиеся непосредственными потомками узла контекста</P>

<LI><P><CODE>child::text()</CODE> собирает все текстовые узлы, являющиеся непосредственными потомками узла контекста</P>

<LI><P><CODE>child::node()</CODE> собирает все непосредственные потомки текущего узла контекста независимо от типа этих узлов</P>

<LI><P><CODE>attribute::name</CODE> в текущем узле контекста находит атрибут <CODE>name</CODE></P>

<LI><P><CODE>attribute::*</CODE> собирает все атрибуты в текущем узле контекста</P>


<LI><P><CODE>descendant::para</CODE> среди потомков узла контекста находит элементы <CODE>para</CODE></P>

<LI><P><CODE>ancestor::div</CODE> собирает все предки <CODE>div</CODE> текущего узла контекста</P>

<LI><P><CODE>ancestor-or-self::div</CODE> собирает предки <CODE>div</CODE> текущего узла контекста и также, если сам узел контекста тоже является элементом <CODE>div</CODE>, включает в набор и его</P>

<LI><P><CODE>descendant-or-self::para</CODE> среди потомков узла контекста выбирает элементы <CODE>para</CODE> а также, если сам узел контекста является элементом <CODE>para</CODE>, то включает в набор и его</P>

<LI><P><CODE>self::para</CODE> выбирает текущий узел контекста, если это элемент <CODE>para</CODE>, либо в противном случае не выбирает ничего</P>

<LI><P><CODE>child::chapter/descendant::para</CODE> выбирает элементы <CODE>para</CODE> среди потомков элемента <CODE>chapter</CODE>, являющегося непосредственным потомком текущего узла контекста</P>

<LI><P><CODE>child::*/child::para</CODE> собирает все <CODE>para</CODE>, являющиеся потомками текущего узла контекста во втором поколении</P>

<LI><P><CODE>/</CODE> находит корень документа (который всегда является родителем элемента документа)</P>

<LI><P><CODE>/descendant::para</CODE> в документе, которому принадлежит узел контекста, находит все элементы <CODE>para</CODE></P>

<LI><P><CODE>/descendant::olist/child::item</CODE> находит все элементы <CODE>item</CODE>, которые имеют родителем <CODE>olist</CODE> и находятся в пределах документа, в котором располагается узел контекста</P>

<LI><P><CODE>child::para[position()=1]</CODE> находит первый непосредственный потомок <CODE>para</CODE> текущего узла контекста</P>

<LI><P><CODE>child::para[position()=last()]</CODE> находит последний непосредственный потомок <CODE>para</CODE> текущего узла контекста</P>

<LI><P><CODE>child::para[position()=last()-1]</CODE> находит предпоследний непосредственный потомок <CODE>para</CODE> текущего узла контекста</P>

<LI><P><CODE>child::para[position()&gt;1]</CODE> среди непосредственных потомков текущего узла контекста собирает все <CODE>para</CODE>, за исключением первого</P>

<LI><P><CODE>following-sibling::chapter[position()=1]</CODE> находит следующий <CODE>chapter</CODE>, имеющий с узлом контекста общего родителя</P>

<LI><P><CODE>preceding-sibling::chapter[position()=1]</CODE> находит предыдущий <CODE>chapter</CODE>,  имеющий с узлом контекста общего родителя</P>

<LI><P><CODE>/descendant::figure[position()=42]</CODE> находит в документе сорок второй элемент <CODE>figure</CODE></P>

<LI><P><CODE>/child::doc/child::chapter[position()=5]/child::section[position()=2]</CODE> находит второй <CODE>section</CODE> в пятом <CODE>chapter</CODE> в элементе документа <CODE>doc</CODE></P>


<LI><P><CODE>child::para[attribute::type="warning"]</CODE> находит все непосредственные потомки <CODE>para</CODE> текущего узла контекста, имеющие атрибут <CODE>type</CODE> со значением <CODE>warning</CODE></P>

<LI><P><CODE>child::para[attribute::type='warning'][position()=5]</CODE> среди непосредственных потомков текущего узла контекста с названием <CODE>para</CODE> и имеющих атрибут <CODE>type</CODE> со значением <CODE>warning</CODE> находит пятый элемент</P>

<LI><P><CODE>child::para[position()=5][attribute::type="warning"]</CODE> среди непосредственных потомков <CODE>para</CODE> узла контекста выбирает пятый элемент, при условии что он имеет атрибут <CODE>type</CODE> со значением <CODE>warning</CODE></P>

<LI><P><CODE>child::chapter[child::title='Introduction']</CODE> среди непосредственных потомков <CODE>chapter</CODE> текущего узла контекста выбирает тот, у которого в свою очередь имеется один или несколько непосредственных потомков <CODE>title</CODE> со <A href="#dt-string-value">строковым значением</A> <CODE>Introduction</CODE></P>

<LI><P><CODE>child::chapter[child::title]</CODE> среди непосредственных потомков текущего узла контекста <CODE>chapter</CODE> находит тот, у которого имеется один или несколько непосредственных потомков <CODE>title</CODE></P>

<LI><P><CODE>child::*[self::chapter or self::appendix]</CODE> среди непосредственных потомков текущего узла контекста находит <CODE>chapter</CODE> и <CODE>appendix</CODE></P>


<LI><P><CODE>child::*[self::chapter or self::appendix][position()=last()]</CODE> из множества  непосредственных потомков текущего узла контекста <CODE>chapter</CODE> и <CODE>appendix</CODE> выбирает последний</P></LI>

</UL>

<P>Пути адресации бывают двух типов: относительные и абсолютные.</P>

<P>Относительный путь адресации состоит из последовательности одного или нескольких шагов адресации, отделенных друг от друга символом <CODE>/</CODE>. Шаги в относительном пути адресации считаются слева направо. На каждом шаге осуществляется отбор узлов, отталкиваясь от некоторого узла контекста. Основная последовательность шагов образуется последовательным перечислением шагов в порядке их выполнения. Сперва, отталкиваясь от узла контекста, последовательность шагов набирает некий набор узлов. Затем каждый узел в этом наборе поочередно используется как узел контекста для следующего шага. Все наборы узлов, полученных после выполнения такого шага, опять собираются вместе. В итоге в полученном объединении будет собран набор узлов, идентифицируемых данной последовательностью шагов. Например, формула <CODE>child::div/child::para</CODE> собирает все элементы <CODE>para</CODE>, являющиеся непосредственными потомками элемента <CODE>div</CODE>, который сам является непосредственным потомком узла контекста, или, иными словами, находит все элементы - потомки во втором поколении <CODE>para</CODE>, родителями которых являются <CODE>div</CODE>.</P>

<P>Абсолютный путь адресации состоит из символа <CODE>/</CODE>, за которым может следовать относительный путь адресации. Сам символ <CODE>/</CODE> находит корневой узел документа, в котором располагался текущий узел контекста. Если за этим символом последовал относительный путь адресации, то получившийся путь адресации будет собирать набор узлов так, как если бы в качестве узла контекста был выбран корневой узел того документа, которому принадлежал действительный текущий узел контекста.</P>

<H5>Пути адресации</H5>

<TABLE class=scrap>

  <TBODY>

  <TR vAlign=baseline>

    <TD><A name=NT-LocationPath></A>[1]&nbsp;&nbsp;&nbsp;</TD>


    <TD>LocationPath</TD>


    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>

    <TD><A 

      href="#NT-RelativeLocationPath">RelativeLocationPath</A></TD>

    <TD></TD></TR>

  <TR vAlign=baseline>

    <TD></TD>

    <TD></TD>

    <TD></TD>

    <TD>| <A 

      href="#NT-AbsoluteLocationPath">AbsoluteLocationPath</A></TD>

    <TD></TD></TR>

  <TR vAlign=baseline>

    <TD><A name=NT-AbsoluteLocationPath></A>[2]&nbsp;&nbsp;&nbsp;</TD>

    <TD>AbsoluteLocationPath</TD>

    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>

    <TD>'/' <A 

      href="#NT-RelativeLocationPath">RelativeLocationPath</A>?</TD>

    <TD></TD></TR>

  <TR vAlign=baseline>

    <TD></TD>

    <TD></TD>

    <TD></TD>

    <TD>| <A 

      href="#NT-AbbreviatedAbsoluteLocationPath">AbbreviatedAbsoluteLocationPath</A></TD>

    <TD></TD></TR>

  <TR vAlign=baseline>

    <TD><A name=NT-RelativeLocationPath></A>[3]&nbsp;&nbsp;&nbsp;</TD>

    <TD>RelativeLocationPath</TD>

    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>

    <TD><A href="#NT-Step">Step</A></TD>

    <TD></TD></TR>


  <TR vAlign=baseline>

    <TD></TD>

    <TD></TD>

    <TD></TD>

    <TD>| <A 

      href="#NT-RelativeLocationPath">RelativeLocationPath</A> 

      '/' <A href="#NT-Step">Step</A></TD>

    <TD></TD></TR>

  <TR vAlign=baseline>

    <TD></TD>


    <TD></TD>

    <TD></TD>

    <TD>| <A 

      href="#NT-AbbreviatedRelativeLocationPath">AbbreviatedRelativeLocationPath</A></TD>


    <TD></TD></TR></TBODY></TABLE>

<H3><A name=section-Location-Steps></A>2.1 Шаги адресации</H3>


<P>Шаги адресации (location step) состоят из трех частей:</P>

<UL>

<LI><P>оси (axis), указывающей дерево взаимоотношений между текущим узлом контекста и узлами, отбираемыми на данном шаге адресации,</P>


<LI><P>правила проверки узлов, указывающего тип и <A href="#dt-expanded-name">расширенное название</A> узлов, отбираемых на данном шаге адресации,</P>

<LI><P>нуля или более предикатов, использующих произвольные выражения для дальнейшего отсева в наборе узлов, собранных на данном шаге адресации.</P></LI></UL>

<P>Синтаксис шага адресации образуется из названия оси и правила проверки узлов, отделенных друг от друга двумя символами двоеточия. За ними следует нуль или более выражений, каждое из которых заключено в квадратные скобки. Например, в выражении <CODE>child::para[position()=1]</CODE> фрагмент <CODE>child</CODE> - это название оси, <CODE>para</CODE> - правило проверки узла, а <CODE>[position()=1]</CODE> - предикат.</P>

<P>Набор узлов, собранных на данном шаге адресации, - это множество узлов, полученных в результате обработки ранее собранного набора узлов с учетом оси, правила проверки узлов и последующего отсева полученного набора узлов каждым из представленных предикатов.</P>

<P>Исходный набор узлов образуется из узлов, имеющих с текущим узлом контекста взаимосвязь, определяемую указанной осью, имеющих тип узла и <A href="#dt-expanded-name">расширенное имя</A>, отвечающих представленному правилу проверки узлов. Например, шаг адресации <CODE>descendant::para</CODE> находит элементы <CODE>para</CODE>, являющиеся потомками текущего узла контекста: <CODE>descendant</CODE> указывает, что каждый узел в первоначальном наборе должен быть потомком текущего узла контекста, а <CODE>para</CODE> указывает, что каждый узел в исходном наборе должен быть элементом с названием <CODE>para</CODE>. Можно использовать оси, описаные в главе <A href="#axes">[<B>2.2 Оси</B>]</A>. Возможные правила проверки описаны в главе <A href="#node-tests">[<B>2.3 Проверка узлов</B>]</A>, причем смысл некоторых правил проверки меняется в зависимости от используемой оси.</P>


<P>Полученный исходный набор узлов фильтруется в соответствии с первым предикатом для получения нового набора узлов, затем этот новый набор фильтруется в соответствии со вторым предикатом и так далее. Окончательный набор узлов и будет тем самым набором, который получен в результате выполнения данного шага адресации. Выбранная ось оказывает влияние на обработку выражения для каждого предиката, а потому семантика предиката строится отталкиваясь от оси.  См. <A href="#predicates">[<B>2.4 Предикаты</B>]</A>.</P>


<H5>Шаги адресации</H5>

<TABLE class=scrap>

<TBODY>

<TR vAlign=baseline>

<TD><A name=NT-Step></A>[4]&nbsp;&nbsp;&nbsp;</TD>

<TD>Step</TD>

<TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>

<TD><A href="#NT-AxisSpecifier">AxisSpecifier</A> <A href="#NT-NodeTest">NodeTest</A> <A href="#NT-Predicate">Predicate</A>*</TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD></TD>

<TD></TD>

<TD></TD>

<TD>| <A href="#NT-AbbreviatedStep">AbbreviatedStep</A></TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD><A name=NT-AxisSpecifier></A>[5]&nbsp;&nbsp;&nbsp;</TD>

<TD>AxisSpecifier</TD>


<TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>

<TD><A href="#NT-AxisName">AxisName</A> '::'</TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD></TD>

<TD></TD>

<TD></TD>


<TD>| <A href="#NT-AbbreviatedAxisSpecifier">AbbreviatedAxisSpecifier</A></TD>

<TD></TD></TR></TBODY></TABLE>

<H3><A name=axes></A>2.2 Оси</H3>

<P>Можно использовать следующие оси:</P>

<UL>

<LI><P>ось <CODE>child</CODE> включает непосредственного потомка текущего узла контекста</P>

<LI><P>ось <CODE>descendant</CODE> состоит из потомков текущего узла контекста. Потомок - это непосредственный потомок, непосредственный потомок непосредственного потомка и так далее. Таким образом, ось потомков не содержит узлы атрибутов и узлы пространств имен.</P>

<LI><P>ось <CODE>parent</CODE> включает <A href="#dt-parent">непосредственного родителя</A> текущего узла контекста, если таковой имеется</P>

<LI><P>ось <CODE>ancestor</CODE> состоит из предков текущего узла контекста. Предки текущего узла контекста - это его <A href="#dt-parent">родитель</A>, родитель родителя и так далее. Таким образом, ось ancestor всегда будет содержать корневой узел, за исключением единственного случая, когда корневой узел является узлом контекста.</P>

<LI><P>ось <CODE>following-sibling</CODE> состоит из всех последующих узлов, которые с узлом контекста имеют общего родителя. Если узлом контекста является узел атрибута или узел пространства имен, ось <CODE>following-sibling</CODE> будет пустой.</P>

<LI><P>ось <CODE>preceding-sibling</CODE> состоит из всех предшествующих узлов, которые с узлом контекста имеют общего родителя. Если узлом контекста является узел атрибута или узел пространства имен, ось <CODE>preceding-sibling</CODE> будет пустой</P>

<LI><P>ось <CODE>following</CODE>. В документе, где располагается текущий узел контекста, находит все узлы, которые записанные после узла контекста. В число отобранных не попадают потомки текущего узла контекста, а также узлы атрибутов и пространств имен.</P>


<LI><P>ось <CODE>preceding</CODE>. В документе, где располагается текущий узел контекста, находит все узлы, которые предшествуют узлу контекста. В число отобранных не попадают предки текущего узла контекста, а также узлы атрибутов и пространств имен.</P>

<LI><P>ось <CODE>attribute</CODE> состоит из атрибутов текущего узла контекста. Если текущий узел контекста не является элементом, ось будет пустой.</P>

<LI><P>ось <CODE>namespace</CODE> состоит из узлов пространства имен, относящихся к текущему узлу контекста. Если текущий узел контекста не является элементом, ось будет пустой.</P>

<LI><P>ось <CODE>self</CODE> содержит только сам текущий узел контекста</P>

<LI><P>ось <CODE>descendant-or-self</CODE> образуется текущим узлом контекста и его потомками</P>

<LI><P>ось <CODE>ancestor-or-self</CODE> образуется текущим узлом контекста и его предками. Как результат, ось ancestor всегда будет включать корневой узел.</P></LI>

</UL>

<BLOCKQUOTE><B>Замечание:</B> Оси <CODE>ancestor</CODE>, <CODE>descendant</CODE>, <CODE>following</CODE>, <CODE>preceding</CODE> и <CODE>self</CODE> осуществляют разбиение документа (если игнорировать узлы атрибутов и пространств имен). При этом указанные оси не пересекаются, а все вместе задействуют все узлы документа.</BLOCKQUOTE>

<H5>Оси</H5>

<TABLE class=scrap>

  <TBODY>

  <TR vAlign=baseline>

    <TD><A name=NT-AxisName></A>[6]&nbsp;&nbsp;&nbsp;</TD>

    <TD>AxisName</TD>

    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>

    <TD>'ancestor'</TD>

    <TD></TD></TR>

  <TR vAlign=baseline>


    <TD></TD>


    <TD></TD>

    <TD></TD>

    <TD>| 'ancestor-or-self'</TD>

    <TD></TD></TR>

  <TR vAlign=baseline>

    <TD></TD>

    <TD></TD>

    <TD></TD>

    <TD>| 'attribute'</TD>

    <TD></TD></TR>

  <TR vAlign=baseline>

    <TD></TD>

    <TD></TD>

    <TD></TD>

    <TD>| 'child'</TD>

    <TD></TD></TR>

  <TR vAlign=baseline>

    <TD></TD>

    <TD></TD>

    <TD></TD>

    <TD>| 'descendant'</TD>

    <TD></TD></TR>

  <TR vAlign=baseline>


    <TD></TD>


    <TD></TD>


    <TD></TD>


    <TD>| 'descendant-or-self'</TD>

    <TD></TD></TR>

  <TR vAlign=baseline>

    <TD></TD>

    <TD></TD>

    <TD></TD>

    <TD>| 'following'</TD>

    <TD></TD></TR>

  <TR vAlign=baseline>

    <TD></TD>

    <TD></TD>

    <TD></TD>

    <TD>| 'following-sibling'</TD>

    <TD></TD></TR>

  <TR vAlign=baseline>

    <TD></TD>

    <TD></TD>

    <TD></TD>

    <TD>| 'namespace'</TD>

    <TD></TD></TR>

  <TR vAlign=baseline>

    <TD></TD>

    <TD></TD>

    <TD></TD>

    <TD>| 'parent'</TD>

    <TD></TD></TR>

  <TR vAlign=baseline>

    <TD></TD>

    <TD></TD>

    <TD></TD>

    <TD>| 'preceding'</TD>

    <TD></TD></TR>

  <TR vAlign=baseline>

    <TD></TD>

    <TD></TD>

    <TD></TD>

    <TD>| 'preceding-sibling'</TD>


    <TD></TD></TR>

  <TR vAlign=baseline>

    <TD></TD>

    <TD></TD>

    <TD></TD>

    <TD>| 'self'</TD>

    <TD></TD></TR></TBODY></TABLE>

<H3><A name=node-tests></A>2.3 Проверка узлов</H3>

<P><A name=dt-principal-node-type></A>Каждая ось имеет <B>основной тип узлов</B> (principal node type). Если ось может содержать элементы, то для такой оси основным типом узлов будут элементы. В противном случае в качестве основного берется тип тех узлов, которые эта ось может содержать. Таким образом,</P>

<UL>

<LI>для оси attribute основным типом узлов является атрибут. 

<LI>для оси namespace основным типом узлов является пространство имен. 

<LI>для остальных осей основным типом узлов является элемент.</LI>

</UL>

<P>

Правило проверки узлов, соответствующее сценарию <A href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A>, имеет результатом true тогда и только тогда, когда тип узла (см. <A href="#data-model">[<B>5 Модель данных</B>]</A>) совпадает с основным типом узлов, а его <A href="#dt-expanded-name">расширенное имя</A> совпадает с <A href="#dt-expanded-name">расширенным именем</A>, указанным этим <A href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A>. Например, <CODE>child::para</CODE> собирает элементы <CODE>para</CODE>, являющиеся непосредственными потомками текущего узла контекста. Если текущий узел контекста не имеет непосредственного потомка <CODE>para</CODE>, то будет получен пустой набор узлов. <CODE>attribute::href</CODE> в текущем узле контекста выбирает атрибут <CODE>href</CODE>. Если текущий узел контекста не имеет атрибута <CODE>href</CODE>, будет получен пустой набор узлов.</P>

<P><A href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A> в правиле для проверки узла, преобразуется в <A href="#dt-expanded-name">расширенное имя</A> с помощью деклараций пространств имен в контексте этого выражения. Точно так же преобразуются названия типов элементов в начальных и конечных тэгах, за исключением того, что не используется пространство имен по умолчанию, декларированное с помощью <CODE>xmlns</CODE>: если <A href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A> не имеет префикса, URI пространства имен будет нулевым (таким же способом обрабатываются названия атрибутов). Если <A href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A> имеет префикс, для которого в контексте выражения нет соответствующей декларации пространства имен, фиксируется ошибка.</P>

<P>Правило проверки узлов <CODE>*</CODE> имеет результатом true для любого узла, если его тип соответствует основному. Например, <CODE>child::*</CODE> найдет все элементы, являющиеся непосредственными потомками текущего узла контекста, а <CODE>attribute::*</CODE> соберет все атрибуты текущего узла контекста.</P>

<P>Правило проверки узлов может иметь вид <A href="http://www.w3.org/TR/REC-xml-names#NT-NCName">NCName</A><CODE>:*</CODE>. В этом случае префикс, так же как и в случае с <A href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A>, преобразуется с помощью деклараций пространства имен в контексте. Если для этого префикса в контексте выражения не найдено соответствующей декларации пространства имен, фиксируется ошибка. Указанное правило проверки узла будет выдавать true для любого узла основного типа, чье <A href="#dt-expanded-name">расширенное имя</A> имеет именно то URI пространства имен, к которому привязан указанный префикс, независимо от локальной части в названии узла.</P>

<P>Правило проверки узлов <CODE>text()</CODE> будет давать результат true для любого текстового узла. Например, <CODE>child::text()</CODE> будет собирать текстовые узлы, являющиеся непосредственными потомками текущего узла контекста. Точно так же, правило проверки узлов <CODE>comment()</CODE> будет выдавать true для любого узла комментария, а правило проверки узлов <CODE>processing-instruction()</CODE> - для любой инструкции обработки. Правило проверки <CODE>processing-instruction()</CODE> может иметь аргумент типа <A href="#NT-Literal">Literal</A>. В этом случае проверка будет давать true для любой инструкции проверки, чье название соответствует значению этого аргумента.</P>

<P>Правило проверки узлов <CODE>node()</CODE> будет выдавать true для любого узла, к какому бы типу он не относится.</P>

<TABLE class=scrap>

  <TBODY>

  <TR vAlign=baseline>

    <TD><A name=NT-NodeTest></A>[7]&nbsp;&nbsp;&nbsp;</TD>

    <TD>NodeTest</TD>

    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>


    <TD><A href="#NT-NameTest">NameTest</A></TD>

    <TD></TD></TR>

  <TR vAlign=baseline>

    <TD></TD>

    <TD></TD>

    <TD></TD>

    <TD>| <A href="#NT-NodeType">NodeType</A> '(' ')'</TD>

    <TD></TD></TR>

  <TR vAlign=baseline>

    <TD></TD>

    <TD></TD>

    <TD></TD>

    <TD>| 'processing-instruction' '(' <A href="#NT-Literal">Literal</A> ')'</TD>

    <TD></TD></TR></TBODY></TABLE>

<H3><A name=predicates></A>2.4 Предикаты</H3>

<P>Оси делятся на прямые и обратные. Ось, содержащая лишь текущий узел контекста или те узлы, которые <A href="#dt-document-order">в документе</A> следуют за ним, называется прямой осью (forward axis). Ось, содержащая текущий узел контекста или те узлы, которые <A href="#dt-document-order">в документе</A> предшествуют ему, называется обратной осью (reverse axis). Таким образом, оси ancestor, ancestor-or-self, preceding и preceding-sibling являются обратными осями, а все остальные - прямыми. Поскольку ось self всегда содержит не более одного узла, то нет разницы, является ли она прямой или обратной. <A name=dt-proximity-position></A><B>Положение близости</B> (proximity position) по отношению к оси для какого-либо члена в наборе узлов определяется как положение узла в наборе, когда последний выстроен в соответствии с порядком следования узлов в документе, если ось является прямой, или в обратном порядке, если ось является обратной. Первая позиция имеет номер 1.
</P>

<P>Для получения нового набора предикат фильтрует имеющийся набор узлов, отталкиваясь от оси. Каждый узел в исходном наборе, подлежащем фильтрации, поочередно становится узлом контекста и для него проверяется <A href="#NT-PredicateExpr">PredicateExpr</A>. При этом в качестве размера контекста используется количество узлов в исходном наборе, а в качестве положения в контексте берется <A href="#dt-proximity-position">положение близости</A> к оси. Если для данного узла <A href="#NT-PredicateExpr">PredicateExpr</A> оценивается как true, то этот узел попадает во вновь создаваемый набор узлов, в противном случае узел туда не попадает.</P>

<P>Проверка <A href="#NT-PredicateExpr">PredicateExpr</A> сводится к обработке <A href="#NT-Expr">Expr</A> и приведению результата к булевому значению. Если результатом обработки является число, оно будет преобразовано в true, если соответствует положению узла в контексте. В противном случае оно преобразуется в false. Если же результат обработки не является числом, то он будет приведен к булевому значению как при вызове функции <B><A href="#function-boolean">boolean</A></B>. Таким образом, путь адресации <CODE>para[3]</CODE> равнозначен <CODE>para[position()=3]</CODE>.</P>

<H5>Предикаты</H5>

<TABLE class=scrap>

  <TBODY>

  <TR vAlign=baseline>

    <TD><A name=NT-Predicate></A>[8]&nbsp;&nbsp;&nbsp;</TD>

    <TD>Predicate</TD>

    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>


    <TD>'[' <A href="#NT-PredicateExpr">PredicateExpr</A> ']'</TD>

    <TD></TD></TR>

  <TR vAlign=baseline>

    <TD><A name=NT-PredicateExpr></A>[9]&nbsp;&nbsp;&nbsp;</TD>

    <TD>PredicateExpr</TD>

    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>

    <TD><A href="#NT-Expr">Expr</A></TD>

    <TD></TD></TR></TBODY></TABLE>

<H3><A name=path-abbrev></A>2.5 Сокращенный синтаксис</H3>

<P>Некоторые примеры путей адресации, использующих сокращенный синтаксис:</P>

<UL>

<LI><P><CODE>para</CODE> находит элемент <CODE>para</CODE>, являющийся непосредственным потомком текущего узла контекста</P>

<LI><P><CODE>*</CODE> находит все элементы, являющиеся непосредственными потомками текущего узла контекста</P>

<LI><P><CODE>text()</CODE> находит все текстовые узлы, являющиеся непосредственными потомками текущего узла контекста</P>

<LI><P><CODE>@name</CODE> выделяет атрибут <CODE>name</CODE> в текущем узле контекста</P>


<LI><P><CODE>@*</CODE> находит все атрибуты текущего узла контекста</P>

<LI><P><CODE>para[1]</CODE> находит первый непосредственный потомок <CODE>para</CODE> текущего узла контекста</P>

<LI><P><CODE>para[last()]</CODE> находит последний непосредственный потомок <CODE>para</CODE> текущего узла контекста </P>

<LI><P><CODE>*/para</CODE> находит все потомки во втором поколении <CODE>para</CODE> текущего узла контекста</P>

<LI><P><CODE>/doc/chapter[5]/section[2]</CODE> в <CODE>doc</CODE> в пятом <CODE>chapter</CODE> находит второй <CODE>section</CODE></P>

<LI><P><CODE>chapter//para</CODE> собирает элементы <CODE>para</CODE>, являющиеся потомками элемента  <CODE>chapter</CODE>, который является непосредственным потомком текущего узла контекста</P>

<LI><P><CODE>//para</CODE> собирает все <CODE>para</CODE>, являющиеся потомками корневого узла  документа, то есть находит все элементы <CODE>para</CODE> в том документе, где располагается текущий узел контекста</P>

<LI><P><CODE>//olist/item</CODE> в документе, где располагается текущий узел контекста, находит все элементы <CODE>item</CODE>, имеющие родителем <CODE>olist</CODE></P>

<LI><P><CODE>.</CODE> выделяет текущий узел контекста</P>

<LI><P><CODE>.//para</CODE> собирает элементы <CODE>para</CODE>, являющиеся потомками текущего узла контекста</P>

<LI><P><CODE>..</CODE> выделяет родителя текущего узла контекста</P>

<LI><P><CODE>../@lang</CODE> выделяет атрибут <CODE>lang</CODE>, принадлежащий родителю текущего узла контекста</P>

<LI><P><CODE>para[@type="warning"]</CODE> находит все непосредственные потомки <CODE>para</CODE> текущего узла контекста, имеющие атрибут <CODE>type</CODE> со значением <CODE>warning</CODE></P>

<LI><P><CODE>para[@type="warning"][5]</CODE> находит пятый по счету из непосредственных потомков <CODE>para</CODE> текущего узла контекста, имеющих атрибут <CODE>type</CODE> со значением <CODE>warning</CODE></P>

<LI><P><CODE>para[5][@type="warning"]</CODE> извлекает пятый непосредственный потомок <CODE>para</CODE> текущего узла контекста, если этот потомок имеет атрибут <CODE>type</CODE> со значением <CODE>warning</CODE></P>

<LI><P><CODE>chapter[title="Introduction"]</CODE> получает непосредственный потомок текущего узла контекста <CODE>chapter</CODE>, который в свою очередь имеет один или несколько непосредственных потомков <CODE>title</CODE> со <A href="#dt-string-value">строковым значением</A>, равным <CODE>Introduction</CODE></P>

<LI><P><CODE>chapter[title]</CODE> находит непосредственный потомок <CODE>chapter</CODE> текущего узла контекста, который имеет один или несколько непосредственных потомков <CODE>title</CODE></P>

<LI><P><CODE>employee[@secretary and @assistant]</CODE> находит все непосредственные потомки <CODE>employee</CODE> данного узла контекста, которые имеют оба атрибута <CODE>secretary</CODE> и <CODE>assistant</CODE></P></LI></UL>

<P>Самой важной является аббревиатура <CODE>child::</CODE>, которую при записи шага адресации всегда можно опустить. Фактически, <CODE>child</CODE> используется как ось по умолчанию. Например, путь адресации <CODE>div/para</CODE> становится сокращением для <CODE>child::div/child::para</CODE>.</P>

<P>Аналогичные аббревиатуры имеются и для атрибутов: <CODE>attribute::</CODE> может быть сокращен до <CODE>@</CODE>. Например, путь адресации <CODE>para[@type="warning"]</CODE> является сокращением для <CODE>child::para[attribute::type="warning"]</CODE>, а следовательно, находит непосредственные потомки <CODE>para</CODE>, имеющие атрибут <CODE>type</CODE>, значение которого равно <CODE>warning</CODE>.</P>

<P><CODE>//</CODE> является сокращением для <CODE>/descendant-or-self::node()/</CODE>. Например, <CODE>//para</CODE> - это сокращение для <CODE>/descendant-or-self::node()/child::para</CODE>, а потому будет находить в документе все элементы <CODE>para</CODE> (путь <CODE>//para</CODE> найдет элемент <CODE>para</CODE>, даже если последний является элементом документа, поскольку узел элемента документа является непосредственным потомком корневого узла). <CODE>div//para</CODE> - это сокращение для <CODE>div/descendant-or-self::node()/child::para</CODE>, а потому находит все потомки <CODE>para</CODE> для непосредственного потомка <CODE>div</CODE>.</P>

<BLOCKQUOTE><B>Замечание:</B> Путь адресации <CODE>//para[1]</CODE> имеет <I>иное</I> значение, чем путь адресации <CODE>/descendant::para[1]</CODE>. Последний отыскивает первый элемент-потомок <CODE>para</CODE>, а предыдущий находит все элементы-потомки <CODE>para</CODE>, являющиеся для своего родителя первым непосредственным потомком <CODE>para</CODE>.</BLOCKQUOTE>

<P>Шаг адресации <CODE>.</CODE> является сокращением для <CODE>self::node()</CODE>. Особенно эта запись полезна в сочетании с <CODE>//</CODE>. Например, путь адресации <CODE>.//para</CODE> является сокращением для</P>

<PRE>self::node()/descendant-or-self::node()/child::para</PRE>

<P>а потому будет находить все элементы <CODE>para</CODE>, являющиеся потомками текущего узла контекста.</P>

<P>Точно так же, шаг адресации <CODE>..</CODE> является сокращением для <CODE>parent::node()</CODE>. Например, <CODE>../title</CODE> - это сокращенная запись для <CODE>parent::node()/child::title</CODE>, а потому для родителя текущего узла контекста будет находить непосредственные потомки <CODE>title</CODE>.</P>

<H5>Аббревиатуры</H5>

<TABLE class=scrap>

<TBODY>


<TR vAlign=baseline>

<TD><A name=NT-AbbreviatedAbsoluteLocationPath></A>[10]&nbsp;&nbsp;&nbsp;</TD>

<TD>AbbreviatedAbsoluteLocationPath</TD>

<TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>

<TD>'//' <A href="#NT-RelativeLocationPath">RelativeLocationPath</A></TD>

<TD></TD></TR>


<TR vAlign=baseline>

<TD><A name=NT-AbbreviatedRelativeLocationPath></A>[11]&nbsp;&nbsp;&nbsp;</TD>

<TD>AbbreviatedRelativeLocationPath</TD>

<TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>

<TD><A href="#NT-RelativeLocationPath">RelativeLocationPath</A> '//' <A href="#NT-Step">Step</A></TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD><A name=NT-AbbreviatedStep></A>[12]&nbsp;&nbsp;&nbsp;</TD>

<TD>AbbreviatedStep</TD>

<TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>


<TD>'.'</TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD></TD>

<TD></TD>

<TD></TD>

<TD>| '..'</TD>


<TD></TD></TR>

<TR vAlign=baseline>

<TD><A name=NT-AbbreviatedAxisSpecifier></A>[13]&nbsp;&nbsp;&nbsp;</TD>

<TD>AbbreviatedAxisSpecifier</TD>


<TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>

<TD>'@'?</TD>

<TD></TD></TR></TBODY></TABLE>

<H2><A name=section-Expressions></A>3 Выражения</H2>

<H3><A name=section-Basics></A>3.1 Основы</H3>

<P><A href="#NT-VariableReference">VariableReference</A> заменяется значением, которое в текущем контексте поставлено в соответствие данному имени переменной (согласно схеме привязки переменных контекста). Если же по схеме привязки переменных контекста с данным именем переменной не связано ни одно значение, фиксируется ошибка.</P>

<P>Для группировки выражений могут использоваться круглые скобки.</P>

<TABLE class=scrap>

<TBODY>

<TR vAlign=baseline>

<TD><A name=NT-Expr></A>[14]&nbsp;&nbsp;&nbsp;</TD>

<TD>Expr</TD>

<TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>

<TD><A href="#NT-OrExpr">OrExpr</A></TD>


<TD></TD></TR>

<TR vAlign=baseline>

<TD><A name=NT-PrimaryExpr></A>[15]&nbsp;&nbsp;&nbsp;</TD>

<TD>PrimaryExpr</TD>

<TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>


<TD><A href="#NT-VariableReference">VariableReference</A></TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD></TD>

<TD></TD>

<TD></TD>

<TD>| '(' <A href="#NT-Expr">Expr</A> ')'</TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD></TD>

<TD></TD>

<TD></TD>

<TD>| <A href="#NT-Literal">Literal</A></TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD></TD>

<TD></TD>

<TD></TD>

<TD>| <A href="#NT-Number">Number</A></TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD></TD>

<TD></TD>

<TD></TD>

<TD>| <A href="#NT-FunctionCall">FunctionCall</A></TD>

<TD></TD></TR></TBODY></TABLE>

<H3><A name=section-Function-Calls></A>3.2 Вызовы функций</H3>

<P>При обработке выражения <A href="#NT-FunctionCall">FunctionCall</A> используется <A href="#NT-FunctionName">FunctionName</A>, позволяющее функцию в выражении сопоставить с библиотекой функций, соответствующей контексту обрабатываемого выражения, обработать каждый из <A href="#NT-Argument">аргументов</A>, приведя к тому типу, который необходим для этой функции, и наконец вызвать саму функцию, передав ей преобразованные аргументы. Если указано неправильное количество аргументов или какой-либо аргумент не может быть приведен к требуемому типу, фиксируется ошибка. Результатом обработки выражения <A href="#NT-FunctionCall">FunctionCall</A> будет результат, возвращаемый соответствующей функцией.</P>

<P>Приведение аргумента к типу string осуществляется как при вызове функции <B><A href="#function-string">string</A></B>. Приведение к типу number осуществляется как при вызове функции <B><A href="#function-number">number</A></B>. Приведение к типу boolean осуществляется как при вызове функции <B><A href="#function-boolean">boolean</A></B>. Аргумент, тип которого не соответствует набору узлов, уже не может быть приведен к этому типу.</P>

<TABLE class=scrap>

<TBODY>

<TR vAlign=baseline>

<TD><A name=NT-FunctionCall></A>[16]&nbsp;&nbsp;&nbsp;</TD>

<TD>FunctionCall</TD>

<TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>


<TD><A href="#NT-FunctionName">FunctionName</A> '(' ( <A href="#NT-Argument">Argument</A> ( ',' <A href="#NT-Argument">Argument</A> )* )? ')'</TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD><A name=NT-Argument></A>[17]&nbsp;&nbsp;&nbsp;</TD>

<TD>Argument</TD>

<TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>

<TD><A href="#NT-Expr">Expr</A></TD>

<TD></TD></TR></TBODY></TABLE>

<H3><A name=node-sets></A>3.3 Наборы узлов</H3>

<P>В качестве выражения может использоваться путь адресации. Результатом обработки такого выражения будет набор узлов, отобранных согласно указанному пути адресации.</P>

<P>Оператор <CODE>|</CODE> находит объединение операндов, которые должны являться наборами узлов.</P>

<P>Точно так же, как и в случае с путями адресации, для фильтрации выражений могут использоваться <A href="#NT-Predicate">предикаты</A>. Однако если результатом обработки выражения, подлежащего фильтрации, будет не набор узлов, фиксируется ошибка. Указанный <A href="#NT-Predicate">предикат</A> осуществляет фильтрацию набора узлов относительно оси child.</P>

<BLOCKQUOTE><B>Замечание:</B> Значение <A href="#NT-Predicate">предиката</A> решающим образом зависит от используемой оси. Например, <CODE>preceding::foo[1]</CODE> возвращает первый элемент <CODE>foo</CODE>, встретившийся при сканировании документа <I>в обратном порядке</I>, поскольку предикат <CODE>[1]</CODE> относится к оси preceding. И наоборот, <CODE>(preceding::foo)[1]</CODE> возвращает первый элемент <CODE>foo</CODE>, обнаруженный при просмотре документа <I>в прямом порядке</I>, поскольку в этом случае с предикатом <CODE>[1]</CODE> связана ось child.</BLOCKQUOTE>

<P>Операторы <CODE>/</CODE> и <CODE>//</CODE> формируют и выражение, и относительный путь адресации. Если результатом обработки такого выражения окажется не набор узлов, фиксируется ошибка. Оператор <CODE>/</CODE> образует композицию в точности так же, как символ <CODE>/</CODE>, использовавшийся в пути адресации. Как и в случае с путями адресации, <CODE>//</CODE> является сокращением для <CODE>/descendant-or-self::node()/</CODE>.</P>

<P>Не существует таких типов объектов, которые можно было бы преобразовать в набор узлов.</P>

<TABLE class=scrap>

<TBODY>

<TR vAlign=baseline>

<TD><A name=NT-UnionExpr></A>[18]&nbsp;&nbsp;&nbsp;</TD>

<TD>UnionExpr</TD>

<TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>

<TD><A href="#NT-PathExpr">PathExpr</A></TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD></TD>

<TD></TD>

<TD></TD>

<TD>| <A href="#NT-UnionExpr">UnionExpr</A> '|' <A href="#NT-PathExpr">PathExpr</A></TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD><A name=NT-PathExpr></A>[19]&nbsp;&nbsp;&nbsp;</TD>

<TD>PathExpr</TD>

<TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>

<TD><A href="#NT-LocationPath">LocationPath</A></TD>




<TD></TD></TR>


<TR vAlign=baseline>

<TD></TD>

<TD></TD>

<TD></TD>

<TD>| <A href="#NT-FilterExpr">FilterExpr</A></TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD></TD>

<TD></TD>

<TD></TD>

<TD>| <A href="#NT-FilterExpr">FilterExpr</A> '/' <A href="#NT-RelativeLocationPath">RelativeLocationPath</A></TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD></TD>

<TD></TD>

<TD></TD>

<TD>| <A href="#NT-FilterExpr">FilterExpr</A> '//' <A href="#NT-RelativeLocationPath">RelativeLocationPath</A></TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD><A name=NT-FilterExpr></A>[20]&nbsp;&nbsp;&nbsp;</TD>

<TD>FilterExpr</TD>

<TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>

<TD><A href="#NT-PrimaryExpr">PrimaryExpr</A></TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD></TD>

<TD></TD>

<TD></TD>

<TD>| <A href="#NT-FilterExpr">FilterExpr</A> <A href="#NT-Predicate">Predicate</A></TD>

<TD></TD></TR></TBODY></TABLE>

<H3><A name=booleans></A>3.4 Булевы значения</H3>


<P>Объект типа boolean может иметь два значения: true и false.</P>

<P>Обработка выражения <CODE>or</CODE> сводится к обработке каждого операнда и приведению его значения к булевому типу, как если бы имел место вызов функции <B><A href="#function-boolean">boolean</A></B>. Если значением какого-либо из операндов будет true, то и значением всего выражения в целом тоже будет true, в противном случае это будет false. Если в результате обработки левого операнда получено true, то обработка правого операнда не производится.</P>

<P>Обработка выражения <CODE>and</CODE> сводится к обработке каждого операнда и приведению его значения к булевому типу, как если бы имел место вызов функции <B><A href="#function-boolean">boolean</A></B>. Если значением обоих операндов будет true, то и значением всего выражения будет true, в противном случае это будет false. Если в результате обработки левого операнда получено false, то обработка правого операнда не производится.</P>

<P>Обработка <A href="#NT-EqualityExpr">EqualityExpr</A> (который содержит не только <A href="#NT-RelationalExpr">RelationalExpr</A>) или <A href="#NT-RelationalExpr">RelationalExpr</A> (который содержит не только <A href="#NT-AdditiveExpr">AdditiveExpr</A>) сводится к сравнению объектов, полученных в результате обработки обоих операндов. Процедура сравнения объектов описывается в трех следующих параграфах. В первом параграфе сравнение наборов узлов определяется через сравнение более элементарных объектов. Это в равной степени относится к <CODE>=</CODE>, <CODE>!=</CODE>, <CODE>&lt;=</CODE>, <CODE>&lt;</CODE>, <CODE>&gt;=</CODE> и <CODE>&gt;</CODE>. Во втором параграфе описываются процедуры сравнения <CODE>=</CODE> и <CODE>!=</CODE> для объектов, не являющихся наборами узлов. В третьем параграфе для объектов, не являющихся наборами узлов, описываются операторы сравнения <CODE>&lt;=</CODE>, <CODE>&lt;</CODE>, <CODE>&gt;=</CODE> и <CODE>&gt;</CODE>.</P>

<P>Если оба сравниваемых объекта являются наборами узлов, то их сравнение будет иметь результатом true тогда и только тогда, когда и в первом и во втором наборах имеются узлы, такие что в результате сравнения <A href="#dt-string-value">строковых значений</A> этих двух узлов имеем true. Если одним из сравниваемых объектов является набор узлов, а вторым - число, то их сравнение будет иметь результатом true тогда и только тогда, когда в представленном наборе имеется такой узел, что сравнение его <A href="#dt-string-value">строкового значения</A>, преобразованного в число с помощью функции <B><A href="#function-number">number</A></B>, со вторым операндом даст в результате true. Если одним из сравниваемых объектов является набор узлов, а вторым строка, то в результате их сравнения true будет получаться тогда и только тогда, когда в наборе имеется такой узел, что результатом сравнения <A href="#dt-string-value">строкового значения</A> этого узла со второй представленной строки будет true. Если одним из сравниваемых объектов является набор узлов, а вторым булево значение, то в результате их сравнения true будет получено тогда и только тогда, когда сравнение представленного булевого значения с результатом приведения набора узлов к булевому значению с помощью функции <B><A href="#function-boolean">boolean</A></B> также даст true.</P>

<P>Если ни один из объектов, подлежащих сравнению, не является набором узлов, а оператором является <CODE>=</CODE> или <CODE>!=</CODE>, то перед сравнением эти объекты приводятся к единому типу по следующему алгоритму: Если по крайней мере один из сравниваемых объектов имеет булевый тип, то оба сравниваемых объекта приводятся к булевому типу как при вызове функции <B><A href="#function-boolean">boolean</A></B>. В противном случае, если хотя бы один из сравниваемых объектов является числом, то оба объекта преобразуется в число как при вызове функции <B><A href="#function-number">number</A></B>. В остальных случаях оба сравниваемых объекта преобразуются в строки как при вызове функции <B><A href="#function-string">string</A></B>. Оператор сравнения <CODE>=</CODE> будет иметь результатом true тогда и только тогда, когда оба объекта идентичны. Оператор сравнения <CODE>!=</CODE> будет иметь результатом true тогда и только тогда, когда объекты неидентичны. Сравнение чисел осуществляется согласно требованиям IEEE 754 <A href="#IEEE754">[IEEE 754]</A>. Два булевых значения равны, если оба являются true или оба являются false. Две строки считаются равными тогда и только тогда, когда обе образованы одной и той же последовательностью UCS символов.</P>

<BLOCKQUOTE><B>Замечание:</B> Если <CODE>$x</CODE> соответствует набору узлов, то выражение <CODE>$x="foo"</CODE> имеет иное значение, чем <CODE>not($x!="foo")</CODE>: Первое выражение имеет результатом true тогда и только тогда, когда в <CODE>$x</CODE> имеется <I>какой-нибудь</I> узел со строковым значением <CODE>foo</CODE>. Второе выражение имеет результатом true когда и только тогда, когда в <CODE>$x</CODE> <I>все</I> узлы имеют строковое значение <CODE>foo</CODE>.
</BLOCKQUOTE>

<P>Если ни один из подлежащих сравнению объектов не является набором узлов, а оператором является <CODE>&lt;=</CODE>, <CODE>&lt;</CODE>, <CODE>&gt;=</CODE> или <CODE>&gt;</CODE>, то сравниваемые объекты сперва преобразуются в числа, а затем выполняется сравнение этих чисел в соответствии с требованиями IEEE 754. Оператор сравнения <CODE>&lt;</CODE> будет давать true тогда и только тогда, когда первое число меньше второго. Оператор сравнения <CODE>&lt;=</CODE> будет давать true тогда и только тогда, когда первое число меньше или равно второму. Оператор сравнения <CODE>&gt;</CODE> будет давать true тогда и только тогда, когда первое число больше второго. Оператор сравнения <CODE>&gt;=</CODE> будет давать true тогда и только тогда, когда первое число больше или равно второму.</P>

<BLOCKQUOTE><B>Замечание:</B> Если в XML документе встречается выражение XPath, то операторы <CODE>&lt;</CODE> и <CODE>&lt;=</CODE> должны быть маскированы в соответствии с правилами XML 1.0, например, заменой на <CODE>&amp;lt;</CODE> и <CODE>&amp;lt;=</CODE> соответственно. В следующем примере значением атрибута <CODE>test</CODE> является выражение XPath: 

<PRE>&lt;xsl:if test="@value &amp;lt; 10"&gt;...&lt;/xsl:if&gt;</PRE>

</BLOCKQUOTE>

<TABLE class=scrap>

<TBODY>

<TR vAlign=baseline>

<TD><A name=NT-OrExpr></A>[21]&nbsp;&nbsp;&nbsp;</TD>

<TD>OrExpr</TD>



<TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>

<TD><A href="#NT-AndExpr">AndExpr</A></TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD></TD>

<TD></TD>

<TD></TD>

<TD>| <A href="#NT-OrExpr">OrExpr</A> 'or' <A href="#NT-AndExpr">AndExpr</A></TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD><A name=NT-AndExpr></A>[22]&nbsp;&nbsp;&nbsp;</TD>

<TD>AndExpr</TD>


<TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>



<TD><A href="#NT-EqualityExpr">EqualityExpr</A></TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD></TD>

<TD></TD>

<TD></TD>

<TD>| <A href="#NT-AndExpr">AndExpr</A> 'and' <A 
href="#NT-EqualityExpr">EqualityExpr</A></TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD><A name=NT-EqualityExpr></A>[23]&nbsp;&nbsp;&nbsp;</TD>

<TD>EqualityExpr</TD>

<TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>

<TD><A href="#NT-RelationalExpr">RelationalExpr</A></TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD></TD>


<TD></TD>


<TD></TD>

<TD>| <A href="#NT-EqualityExpr">EqualityExpr</A> '=' <A href="#NT-RelationalExpr">RelationalExpr</A></TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD></TD>

<TD></TD>

<TD></TD>

<TD>| <A href="#NT-EqualityExpr">EqualityExpr</A> '!=' <A href="#NT-RelationalExpr">RelationalExpr</A></TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD><A name=NT-RelationalExpr></A>[24]&nbsp;&nbsp;&nbsp;</TD>

<TD>RelationalExpr</TD>

<TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>

<TD><A href="#NT-AdditiveExpr">AdditiveExpr</A></TD>

<TD></TD></TR>


<TR vAlign=baseline>

<TD></TD>

<TD></TD>

<TD></TD>


<TD>| <A href="#NT-RelationalExpr">RelationalExpr</A> '&lt;' <A href="#NT-AdditiveExpr">AdditiveExpr</A></TD>

<TD></TD></TR>


<TR vAlign=baseline>

<TD></TD>

<TD></TD>

<TD></TD>

<TD>| <A href="#NT-RelationalExpr">RelationalExpr</A> '&gt;' <A href="#NT-AdditiveExpr">AdditiveExpr</A></TD>


<TD></TD></TR>

<TR vAlign=baseline>

<TD></TD>

<TD></TD>

<TD></TD>

<TD>| <A href="#NT-RelationalExpr">RelationalExpr</A> '&lt;=' <A href="#NT-AdditiveExpr">AdditiveExpr</A></TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD></TD>

<TD></TD>

<TD></TD>

<TD>| <A href="#NT-RelationalExpr">RelationalExpr</A> '&gt;=' <A href="#NT-AdditiveExpr">AdditiveExpr</A></TD>

<TD></TD></TR></TBODY></TABLE>

<BLOCKQUOTE><B>Замечание:</B> Согласно представленной выше грамматике, операторы будут иметь следующий порядок приоритета (наименьший приоритет идет первым):

<UL>

<LI><P><CODE>or</CODE></P>

<LI><P><CODE>and</CODE></P>

<LI><P><CODE>=</CODE>, <CODE>!=</CODE></P>

<LI><P><CODE>&lt;=</CODE>, <CODE>&lt;</CODE>, <CODE>&gt;=</CODE>, <CODE>&gt;</CODE> </P></LI>

</UL>

Все указанные операторы имеют ассоциативность слева. Например, выражение <CODE>3 &gt; 2 &gt; 1</CODE> эквивалентно выражению <CODE>(3 &gt; 2) &gt; 1</CODE>, имеющему значение false. </BLOCKQUOTE>

<H3><A name=numbers></A>3.5 Числа</H3>

<P>Число в XPath имеет представление с плавающей точкой. Число может принимать любое значение в 64-битном формате IEEE 754 двойной точности <A href="#IEEE754">[IEEE 754]</A>. Сюда включены специальное значение "Not-a-Number" (NaN), положительная и отрицательная бесконечности, а также положительный и отрицательный нули. Список основных правил стандарта IEEE 754 см. в <A href="http://java.sun.com/docs/books/jls/html/4.doc.html#9208">главе 4.2.3</A> документа <A href="#JLS">[JLS]</A></P>

<P>Операнды для числовых операторов преобразуются в числа как при вызове функции <B><A href="#function-number">number</A></B>.</P>

<P>Оператор <CODE>+</CODE> выполняет сложение.</P>

<P>Оператор <CODE>-</CODE> осуществляет вычитание.</P>

<BLOCKQUOTE><B>Замечание:</B> поскольку язык XML допускает использование в именах символа <CODE>-</CODE>, то оператору вычитания <CODE>-</CODE>, как правило, должен предшествовать символ пробела. Например, запись <CODE>foo-bar</CODE> обрабатывается как набор элементов с названием <CODE>foo-bar</CODE>, являющихся непосредственными потомками, тогда как <CODE>foo - bar</CODE> обрабатывается как разница результатов преобразования в число <A href="#dt-string-value">строковых значений</A> элементов <CODE>foo</CODE> и <CODE>bar</CODE>, также являющихся непосредственными потомками.</BLOCKQUOTE>

<P>Оператор <CODE>div</CODE> осуществляет деление чисел с плавающей точкой в соответствии с требованиями IEEE 754.</P>

<P>Оператор <CODE>mod</CODE> возвращает остаток от усекающего деления. Например,</P>

<UL>

<LI><P><CODE>5 mod 2</CODE> возвращает <CODE>1</CODE> </P>

<LI><P><CODE>5 mod -2</CODE> возвращает <CODE>1</CODE> </P>

<LI>
<P><CODE>-5 mod 2</CODE> возвращает <CODE>-1</CODE> </P>

<LI><P><CODE>-5 mod -2</CODE> возвращает <CODE>-1</CODE> </P></LI></UL>

<BLOCKQUOTE><B>Замечание:</B> Указанный оператор аналогичен оператору <CODE>%</CODE> в Java или ECMAScript.</BLOCKQUOTE>

<BLOCKQUOTE><B>Замечание:</B> Данный оператор отличается от оператора remainder из IEEE 754, который возвращает остаток округляющего деления.</BLOCKQUOTE>

<H5>Числовые выражения</H5>

<TABLE class=scrap>

<TBODY>

<TR vAlign=baseline>

<TD><A name=NT-AdditiveExpr></A>[25]&nbsp;&nbsp;&nbsp;</TD>

<TD>AdditiveExpr</TD>

<TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>


<TD><A href="#NT-MultiplicativeExpr">MultiplicativeExpr</A></TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD></TD>

<TD></TD>

<TD></TD>

<TD>| <A href="#NT-AdditiveExpr">AdditiveExpr</A> '+' <A href="#NT-MultiplicativeExpr">MultiplicativeExpr</A></TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD></TD>

<TD></TD>

<TD></TD>

<TD>| <A href="#NT-AdditiveExpr">AdditiveExpr</A> '-' <A href="#NT-MultiplicativeExpr">MultiplicativeExpr</A></TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD><A name=NT-MultiplicativeExpr></A>[26]&nbsp;&nbsp;&nbsp;</TD>

<TD>MultiplicativeExpr</TD>

<TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>

<TD><A href="#NT-UnaryExpr">UnaryExpr</A></TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD></TD>

<TD></TD>

<TD></TD>

<TD>| <A href="#NT-MultiplicativeExpr">MultiplicativeExpr</A> <A href="#NT-MultiplyOperator">MultiplyOperator</A> <A href="#NT-UnaryExpr">UnaryExpr</A></TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD></TD>

<TD></TD>

<TD></TD>

<TD>| <A href="#NT-MultiplicativeExpr">MultiplicativeExpr</A> 
'div' <A href="#NT-UnaryExpr">UnaryExpr</A></TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD></TD>

<TD></TD>

<TD></TD>

<TD>| <A href="#NT-MultiplicativeExpr">MultiplicativeExpr</A> 'mod' <A href="#NT-UnaryExpr">UnaryExpr</A></TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD><A name=NT-UnaryExpr></A>[27]&nbsp;&nbsp;&nbsp;</TD>

<TD>UnaryExpr</TD>

<TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>

<TD><A href="#NT-UnionExpr">UnionExpr</A></TD>

<TD></TD></TR>

<TR vAlign=baseline>


<TD></TD>


<TD></TD>


<TD></TD>


<TD>| '-' <A href="#NT-UnaryExpr">UnaryExpr</A></TD>

<TD></TD></TR></TBODY></TABLE>

<H3><A name=strings></A>3.6 Строки</H3>

<P>Строки образуются последовательностью из нуля и более символов, определенных в Рекомендации XML <A href="#XML">[XML]</A>. Следовательно, в XPath каждый символ соответствует единственному абстрактному символу Unicode с единственным соответствующим скалярным значением Unicode (см. <A href="#UNICODE">[Unicode]</A>). Это не то же самое, что 16-битное значение кода Unicode, когда абстрактный символ со скалярным значением, большим чем U+FFFF, представляется в кодировке Unicode парой 16-битных значений (суррогатной парой). Во многих языках программирования строка представляется в виде последовательности 16-битных значений кодировки Unicode. Реализация XPath с помощью таких языков должна гарантировать, что каждая суррогатная пара обрабатывается именно как один символ XPath.</P>

<BLOCKQUOTE><B>Замечание:</B> В кодировке Unicode две строки могут считаться идентичными даже несмотря на то, что они образованы различными последовательностями абстрактных символов Unicode. Например, некоторые ударные символы могут быть представлены как в собранном (precompressed), так и в разобранном (decompressed) виде. Поэтому выражения XPath могут дать неожиданный результат, если такие символы в XPath выражении и в XML документе не были нормализованы в каноническую форму. См. документ <A href="#CHARMOD">[Character Model]</A>.</BLOCKQUOTE>

<H3><A name=exprlex></A>3.7 Лексическая структура</H3>


<P>В результате лексического анализа всегда возвращается самая длинная из возможных лексем.</P>

<P>Для большего удобства чтения в выражения могут быть вставлены пробельные символы, даже если грамматика и не содержит на то явных указаний: в шаблонах перед любым <A href="#NT-ExprToken">ExprToken</A> и после него всегда можно свободно поставить <A href="#NT-ExprWhitespace">ExprWhitespace</A>.</P>

<P>Чтобы устранить указанную неоднозначность грамматики <A href="#NT-ExprToken">ExprToken</A>, должны применяться следующие специальные правила лексического анализа:</P>


<UL>

<LI><P>Если предыдущей лексемой было не <CODE>@</CODE>, <CODE>::</CODE>, <CODE>(</CODE>, <CODE>[</CODE>, <CODE>,</CODE> или <A href="#NT-Operator">Operator</A>, то лексема <CODE>*</CODE> должна распознаваться как оператор умножения <A href="#NT-MultiplyOperator">MultiplyOperator</A>, а <A href="http://www.w3.org/TR/REC-xml-names#NT-NCName">NCName</A> - как <A href="#NT-OperatorName">OperatorName</A>.</P>

<LI><P>Если за <A href="http://www.w3.org/TR/REC-xml-names#NT-NCName">NCName</A> следует символ круглой скобки <CODE>(</CODE> (возможно не сразу, а через <A href="#NT-ExprWhitespace">ExprWhitespace</A>), то эта лексема должна распознаваться как <A href="#NT-NodeType">NodeType</A> или <A href="#NT-FunctionName">FunctionName</A>.</P>

<LI><P>Если за <A href="http://www.w3.org/TR/REC-xml-names#NT-NCName">NCName</A> следуют два символа двоеточия <CODE>::</CODE> (возможно не сразу, а через <A href="#NT-ExprWhitespace">ExprWhitespace</A>), то данная лексема должна распознаваться как <A href="#NT-AxisName">AxisName</A>.</P>

<LI><P>В остальных случаях лексема не должна распознаваться как <A href="#NT-MultiplyOperator">MultiplyOperator</A>, <A href="#NT-OperatorName">OperatorName</A>, <A href="#NT-NodeType">NodeType</A>, <A href="#NT-FunctionName">FunctionName</A> или <A href="#NT-AxisName">AxisName</A>.</P></LI>

</UL>


<H5>Лексическая структура выражения</H5>

<TABLE class=scrap>

<TBODY>

<TR vAlign=baseline>

<TD><A name=NT-ExprToken></A>[28]&nbsp;&nbsp;&nbsp;</TD>

<TD>ExprToken</TD>


<TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>

<TD>'(' | ')' | '[' | ']' | '.' | '..' | '@' | ',' | '::'</TD>

<TD></TD></TR>

<TR vAlign=baseline>


<TD></TD>

<TD></TD>

<TD></TD>

<TD>| <A href="#NT-NameTest">NameTest</A></TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD></TD>

<TD></TD>

<TD></TD>

<TD>| <A href="#NT-NodeType">NodeType</A></TD>

<TD></TD></TR>

<TR vAlign=baseline>


<TD></TD>

<TD></TD>

<TD></TD>

<TD>| <A href="#NT-Operator">Operator</A></TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD></TD>

<TD></TD>

<TD></TD>

<TD>| <A href="#NT-FunctionName">FunctionName</A></TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD></TD>

<TD></TD>

<TD></TD>

<TD>| <A href="#NT-AxisName">AxisName</A></TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD></TD>

<TD></TD>

<TD></TD>

<TD>| <A href="#NT-Literal">Literal</A></TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD></TD>

<TD></TD>

<TD></TD>

<TD>| <A href="#NT-Number">Number</A></TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD></TD>

<TD></TD>

<TD></TD>

<TD>| <A href="#NT-VariableReference">VariableReference</A></TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD><A name=NT-Literal></A>[29]&nbsp;&nbsp;&nbsp;</TD>

<TD>Literal</TD>

<TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>

<TD>'"' [^"]* '"'</TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD></TD>

<TD></TD>

<TD></TD>

<TD>| "'" [^']* "'"</TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD><A name=NT-Number></A>[30]&nbsp;&nbsp;&nbsp;</TD>

<TD>Number</TD>

<TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>

<TD><A href="#NT-Digits">Digits</A> ('.' <A href="#NT-Digits">Digits</A>?)?</TD>

<TD></TD></TR>


<TR vAlign=baseline>


<TD></TD>

<TD></TD>

<TD></TD>

<TD>| '.' <A href="#NT-Digits">Digits</A></TD>

<TD></TD></TR>


<TR vAlign=baseline>

<TD><A name=NT-Digits></A>[31]&nbsp;&nbsp;&nbsp;</TD>

<TD>Digits</TD>

<TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>

<TD>[0-9]+</TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD><A name=NT-Operator></A>[32]&nbsp;&nbsp;&nbsp;</TD>


<TD>Operator</TD>

<TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>


<TD><A href="#NT-OperatorName">OperatorName</A></TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD></TD>

<TD></TD>

<TD></TD>

<TD>| <A href="#NT-MultiplyOperator">MultiplyOperator</A></TD>

<TD></TD></TR>

<TR vAlign=baseline>


<TD></TD>

<TD></TD>

<TD></TD>

<TD>| '/' | '//' | '|' | '+' | '-' | '=' | '!=' | '&lt;' | '&lt;=' | '&gt;' | '&gt;='</TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD><A name=NT-OperatorName></A>[33]&nbsp;&nbsp;&nbsp;</TD>

<TD>OperatorName</TD>

<TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>

<TD>'and' | 'or' | 'mod' | 'div'</TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD><A name=NT-MultiplyOperator></A>[34]&nbsp;&nbsp;&nbsp;</TD>

<TD>MultiplyOperator</TD>

<TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>

<TD>'*'</TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD><A name=NT-FunctionName></A>[35]&nbsp;&nbsp;&nbsp;</TD>

<TD>FunctionName</TD>


<TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>

<TD><A href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A> - <A href="#NT-NodeType">NodeType</A> </TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD><A name=NT-VariableReference></A>[36]&nbsp;&nbsp;&nbsp;</TD>

<TD>VariableReference</TD>

<TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>

<TD>'$' <A href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A></TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD><A name=NT-NameTest></A>[37]&nbsp;&nbsp;&nbsp;</TD>

<TD>NameTest</TD>

<TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>

<TD>'*'</TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD></TD>

<TD></TD>

<TD></TD>

<TD>| <A href="http://www.w3.org/TR/REC-xml-names#NT-NCName">NCName</A> ':' '*'</TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD></TD>

<TD></TD>

<TD></TD>

<TD>| <A href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A></TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD><A name=NT-NodeType></A>[38]&nbsp;&nbsp;&nbsp;</TD>

<TD>NodeType</TD>

<TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>

<TD>'comment'</TD>

<TD></TD></TR>


<TR vAlign=baseline>


<TD></TD>

<TD></TD>

<TD></TD>

<TD>| 'text'</TD>


<TD></TD></TR>

<TR vAlign=baseline>

<TD></TD>

<TD></TD>

<TD></TD>

<TD>| 'processing-instruction'</TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD></TD>

<TD></TD>

<TD></TD>

<TD>| 'node'</TD>

<TD></TD></TR>

<TR vAlign=baseline>

<TD><A name=NT-ExprWhitespace></A>[39]&nbsp;&nbsp;&nbsp;</TD>

<TD>ExprWhitespace</TD>

<TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>

<TD><A href="http://www.w3.org/TR/REC-xml#NT-S">S</A></TD>


<TD></TD></TR></TBODY></TABLE>

<H2><A name=corelib></A>4 Основная библиотека функций</H2>

<P>В данной главе описываются функции, которые при реализации XPath должны быть всегда внесены в библиотеку функций, используемых для обработки выражений.</P>

<P>Каждая функция в этой библиотеке описывается с помощью прототипа, в котором указываются тип возвращаемого значения, название функции и тип аргументов. Если за описанием типа аргумента следует знак вопроса, то данный аргумент является необязательным, в противном случае аргумент обязателен.</P>

<H3><A name=section-Node-Set-Functions></A>4.1 Функции обработки набора узлов</H3>

<P><A name=function-last><B>Функция: </B><I>number</I> <B>last</B>()</A> </P>

<P>Функция <B><A href="#function-last">last</A></B> возвращает число, равное <A href="#dt-context-size">размеру контекста</A> обрабатываемого выражения.</P>

<P><A name=function-position><B>Функция: </B><I>number</I> <B>position</B>()</A> </P>

<P>Функция <B><A href="#function-position">position</A></B> возвращает число, равное <A href="#dt-context-position">положению в контексте</A> обрабатываемого выражения.</P>

<P><A name=function-count><B>Функция: </B><I>number</I> <B>count</B>(<I>node-set</I>)</A> </P>

<P>Функция <B><A href="#function-count">count</A></B> возвращает количество узлов в наборе, представленном в качестве аргумента.</P>

<P><A name=function-id><B>Функция: </B><I>node-set</I> <B>id</B>(<I>object</I>)</A> </P>

<P>Функция <B><A href="#function-id">id</A></B> находит элементы по их уникальному идентификатору (см. <A href="#unique-id">[<B>5.2.1 Уникальные ID</B>]</A>). Если аргументом функции <B><A href="#function-id">id</A></B> является набор узлов, то ее результатом будет объединение узлов, полученных в результате вызова функции <B><A href="#function-id">id</A></B> для <A href="#dt-string-value">строкового значения</A> каждого узла в наборе, указанном в качестве аргумента. Если аргумент функции <B><A href="#function-id">id</A></B> относится к какому-либо другому типу, то этот аргумент сперва преобразуется в строку как при вызове функции <B><A href="#function-string">string</A></B>. Затем полученная строка разбивается на лексемы, разделенные пробельными символами (пробельный символ - это любая последовательность символов, соответствующих сценарию <A href="http://www.w3.org/TR/REC-xml#NT-S">S</A>). Результатом вызова функции в этом случае является набор узлов, состоящий из элементов, относящихся к тому же документу, где находился узел контекста, и имеющих уникальный идентификатор, равный одной из лексем, представленных в этом списке.</P>

<UL>

<LI><P><CODE>id("foo")</CODE> находит элемент с уникальным идентификатором <CODE>foo</CODE></P>

<LI><P><CODE>id("foo")/child::para[position()=5]</CODE> среди непосредственных потомков элемента с уникальным идентификатором <CODE>foo</CODE> находит пятый элемент <CODE>para</CODE></P></LI>

</UL>

<P><A name=function-local-name><B>Функция: </B><I>string</I> <B>local-name</B>(<I>node-set</I>?)</A></P>

<P>Среди набора узлов, указанного в аргументе, функция <B><A href="#function-local-name">local-name</A></B> находит тот узел, который <A href="#dt-document-order">в документе встретится первым</A>, и выделяет локальную часть его <A href="#dt-expanded-name">расширенного имени</A>. Если в аргументе функции представлен пустой набор узлов или первый обнаруженный узел не имеет <A href="#dt-expanded-name">расширенного имени</A>, возвращается пустая строка. Если аргумент функции отсутствует, то по умолчанию используется набор, состоящий из единственного члена - узла контекста.</P>

<P><A name=function-namespace-uri><B>Функция: </B><I>string</I> <B>namespace-uri</B>(<I>node-set</I>?)</A></P>

<P>В наборе, указанном в аргументе, функция <B><A href="#function-namespace-uri">namespace-uri</A></B> находит тот узел, который <A href="#dt-document-order"> в документе встретится первым</A>, и в его <A href="#dt-expanded-name">расширенном имени</A> выделяет URI пространства имен. Если указанный в аргументе набор узлов пуст, первый найденный узел не имеет <A href="#dt-expanded-name">расширенного имени</A>, или же URI пространства имен в <A href="#dt-expanded-name">расширенном имени</A> оказался нулевым, то функция возвращает пустую строку. Если аргумент отсутствует, то по умолчанию берется набор, в котором узел контекста является единственным членом.</P>


<BLOCKQUOTE><B>Замечание:</B> Для узлов, которые не соответствуют ни элементам, ни атрибутам, функция <B><A href="#function-namespace-uri">namespace-uri</A></B> возвращает пустую строку.</BLOCKQUOTE>

<P><A name=function-name><B>Функция: </B><I>string</I> <B>name</B>(<I>node-set</I>?)</A> </P>

<P>В наборе, указанном в аргументе, функция <B><A href="#function-name">name</A></B> находит узел, который <A href="#dt-document-order">в документе встретится первым</A>, и возвращает строку, содержащую <A href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A>, которое представляет <A href="#dt- expanded-name">расширенное имя</A> данного узла. Указанная конструкция <A href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A> должна представлять <A href="#dt-expanded-name">расширенное имя</A>, исходя из деклараций пространств имен, доступная для того узла, чье <A href="#dt-expanded-name">расширенное имя</A> должно быть представлено. Как правило, это тот самый <A href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A>, который был представлен в исходном документе XML. Однако это не обязательно должно быть так в случае, когда декларации, воздействующие на данный узел, с одним и тем же пространством имен связывают несколько префиксов. Тем не менее, реализация может содержать сведения о первоначальном префиксе представляемых узлов, в таком случае может выполняться проверка с тем, чтобы возвращаемая строка была всегда такой же, как <A href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A>, используемый в исходном документе XML. Если указанный в аргументе набор узлов пуст или первый узел не имеет <A href="#dt-expanded-name">расширенного имени</A>, возвращается пустая строка. Если аргумент опущен, то по умолчанию используется набор, содержащий только узел контекста.</P>

<BLOCKQUOTE><B>Замечание:</B> Для узлов, не являющихся ни элементом, ни атрибутом, строка, возвращаемая функцией <B><A href="#function-name">name</A></B>, будет той же самой, что и строка, возвращаемая функцией <B><A href="#function-local-name">local-name</A></B>.</BLOCKQUOTE>

<H3><A name=section-String-Functions></A>4.2 Функции обработки строк</H3>

<P><A name=function-string><B>Функция: </B><I>string</I> <B>string</B>(<I>object</I>?)</A> </P>

<P>Функция <B><A href="#function-string">string</A></B> преобразует объект в строку следующим образом:</P>

<UL>

<LI><P>Набор узлов преобразуется в строку, соответствующую <A href="#dt-string-value">строковому значению</A> того узла в этом наборе, который <A href="#dt-document-order">первым встретится в документе</A>. Если представленный набор узлов пуст, возвращается пустая строка.</P>

<LI><P>Число преобразуется в строку следующим образом</P>

<UL>

<LI><P>NaN преобразуется в строку <CODE>NaN</CODE> </P>

<LI><P>положительный нуль преобразуется в строку <CODE>0</CODE> </P>

<LI><P>отрицательный нуль преобразуется в строку <CODE>0</CODE> </P>

<LI><P>положительная бесконечность преобразуется в строку <CODE>Infinity</CODE> </P>

<LI><P>отрицательная бесконечность преобразуется в строку <CODE>-Infinity</CODE> </P>

<LI><P>Если число целое, то оно представляется в десятичной форме <A href="#NT-Number">Number</A> без десятичной точки и ведущих нулей. Если число отрицательное, то его представлению предшествует знак минус (<CODE>-</CODE>).</P>

<LI><P>В противном случае число представляется в десятичной форме <A href="#NT-Number">Number</A>, включающей десятичную точку, по крайней мере одну цифру до десятичной точки и, по крайней мере, одну после. Если число отрицательное, то его представлению предшествует знак минус (<CODE>-</CODE>). Десятичной точке не должны предшествовать ведущие нули, за исключением одной обязательной цифры перед десятичной точкой. После десятичной точки должна следовать хотя бы одна цифра, вообще же количество цифр после точки должно быть ровно таким, сколько необходимо, чтобы отличить это число от других чисел в формате IEEE 754, но не большим.</P></LI>

</UL>

<LI><P>Булево значение false преобразуется в строку <CODE>false</CODE>. Булево значение true преобразуется в строку <CODE>true</CODE>.</P>

<LI><P>Способ преобразования в строку объекта, не относящегося к четырем основным типам, зависит от этого типа.</P></LI>

</UL>

<P>Если аргумент опущен, то по умолчанию используется набор узлов, единственным членом которого является узел контекста.</P>


<BLOCKQUOTE><B>Замечание:</B> Функция <CODE>string</CODE> не предназначена для преобразования чисел в строки для показа пользователю. Для этой цели предназначены функция <CODE>format-number</CODE> и элемент <CODE>xsl:number</CODE> из <A href="#XSLT">[XSLT]</A>.</BLOCKQUOTE>

<P><A name=function-concat><B>Функция: </B><I>string</I> <B>concat</B>(<I>string</I>, <I>string</I>, <I>string</I>*)</A> </P>

<P>Функция <B><A href="#function-concat">concat</A></B> возвращает объединение представленных аргументов.</P>


<P><A name=function-starts-with><B>Функция: </B><I>boolean</I> <B>starts-with</B>(<I>string</I>, <I>string</I>)</A> </P>



<P>Функция <B><A href="#function-starts-with">starts-with</A></B> возвращает true если строка второго аргумента совпадает с началом строки первого аргумента. В противном случае функция возвращает false.</P>

<P><A name=function-contains><B>Функция: </B><I>boolean</I> <B>contains</B>(<I>string</I>, <I>string</I>)</A> </P>

<P>Функция <B><A href="#function-contains">contains</A></B> возвращает true если строка второго аргумента является частью строки первого аргумента. В противном случае функция возвращает false.</P>

<P><A name=function-substring-before><B>Функция: </B><I>string</I> <B>substring-before</B>(<I>string</I>, <I>string</I>)</A> </P>

<P>

Функция <B><A href="#function-substring-before">substring-before</A></B> возвращает ту часть строки первого аргумента, которая предшествует первому появлению строки второго аргумента. Если строка второго аргумента не содержится в строке первого аргумента, то функция возвращает пустую строку. Например, <CODE>substring-before("1999/04/01","/")</CODE> возвратит <CODE>1999</CODE>.</P>

<P><A name=function-substring-after><B>Функция: </B><I>string</I> <B>substring-after</B>(<I>string</I>, <I>string</I>)</A> </P>

<P>Функция <B><A href="#function-substring-after">substring-after</A></B> возвращает ту часть строки первого аргумента, которая следует за первым появлением строки второго аргумента. Если строка второго аргумента не содержится в строке первого аргумента, функция возвращает пустую строку. Например, <CODE>substring-after("1999/04/01","/")</CODE> возвращает <CODE>04/01</CODE>, а <CODE>substring-after("1999/04/01","19")</CODE> возвращает <CODE>99/04/01</CODE>.</P>


<P><A name=function-substring><B>Функция: </B><I>string</I> 
<B>substring</B>(<I>string</I>, <I>number</I>, <I>number</I>?)</A> </P>

<P>Функция <B><A href="#function-substring">substring</A></B> возвращает ту часть строки первого аргумента, которая начинается с позиции, указанной вторым аргументом, и имеет длину, указанную в третьем аргументе. Например, <CODE>substring("12345",2,3)</CODE> возвращает <CODE>"234"</CODE>. Если третий аргумент не был представлен, функция возвращает подстроку, начинающуюся с позиции, указанной во втором аргументе, и продолжащуюся до конца строки. Например, <CODE>substring("12345",2)</CODE> возвращает <CODE>"2345"</CODE>.</P>

<P>Точнее выражаясь, каждый символ в строке (см. <A href="#strings">[<B>3.6 Строки</B>]</A>) имеет номер позиции: позиция первого символа - 1, второго символа - 2 и т.д.</P>

<BLOCKQUOTE><B>Замечание:</B> Такой порядок отличается от принятого в Java и ECMAScript, где метод <CODE>String.substring</CODE> считает позицию первого символа нулевой.</BLOCKQUOTE>

<P>Возвращаемая подстрока содержит те символы, позиция которых больше или равна округленному значению второго аргумента, а также, если был указан третий аргумент, меньше чем сумма округленных значений второго и третьего аргументов. Использовавшиеся выше операции сравнения и сложения отвечают правилам стандарта IEEE 754, округление осуществляется как при вызове функции <B><A href="#function-round">round</A></B>. Приведенные далее примеры иллюстрируют различные нестандартные ситуации:</P>

<UL>

<LI><P><CODE>substring("12345", 1.5, 2.6)</CODE> возвращает <CODE>"234"</CODE></P>

<LI><P><CODE>substring("12345", 0, 3)</CODE> возвращает <CODE>"12"</CODE></P>

<LI><P><CODE>substring("12345", 0 div 0, 3)</CODE> возвращает <CODE>""</CODE></P>


<LI><P><CODE>substring("12345", 1, 0 div 0)</CODE> возвращает <CODE>""</CODE></P>

<LI><P><CODE>substring("12345", -42, 1 div 0)</CODE> возвращает <CODE>"12345"</CODE></P>

<LI><P><CODE>substring("12345", -1 div 0, 1 div 0)</CODE> возвращает <CODE>""</CODE></P></LI>

</UL>


<P><A name=function-string-length><B>Функция: </B><I>number</I> <B>string-length</B>(<I>string</I>?)</A> </P>

<P>Функция <B><A href="#function-string-length">string-length</A></B> возвращает число символов в строке (см. <A Функция ref="#strings">[<B>3.6 Строки</B>]</A>). Если аргумент опущен, то по умолчанию берется узел контекста и преобразуется в строку, иными словами, берется <A href="#dt-string-value">строковое значение</A> текущего узла контекста.</P>

<P><A name=function-normalize-space><B>Функция: </B><I>string</I> <B>normalize-space</B>(<I>string</I>?)</A> </P>

<P>Функция <B><A href="#function-normalize-space">normalize-space</A></B> возвращает строку аргумента с нормализацией пробельных символов. Сюда входит удаление начальных и завершающих пробельных символов, а также замена оставшихся последовательностей пробельных символов одиночными пробелами. Пробельными считаются символы, являющиеся таковыми согласно сценарию <A href="http://www.w3.org/TR/REC-xml#NT-S">S</A> в языке XML. Если аргумент опущен, то по умолчанию в строку преобразуется узел контекста, иными словами, в качестве аргумента берется <A href="#dt-string-value">строковое значение</A> текущего узла контекста.</P>

<P><A name=function-translate><B>Функция:</B> <I>string</I> <B>translate</B>(<I>string</I>, <I>string</I>, <I>string</I>)</A> </P>


<P>Функция <B><A href="#function-translate">translate</A></B> возвращает строку первого аргумента, в которой символы, указанные в строке второго аргумента, заменены символами строки третьего аргумента в соответствующей позиции. Например, <CODE>translate("bar","abc","ABC")</CODE> возвращает строку <CODE>BAr</CODE>. Если в строке второго аргумента имеется символ, для которого нет парного символа в соответствующей позиции третьей строки (поскольку строка второго аргумента длиннее строки третьего аргумента), то все экземпляры этого символа изымаются из первой строки. Например, <CODE>translate("--aaa--","abc-","ABC")</CODE> возвращает <CODE>"AAA"</CODE>. Если какой-либо символ встретился во второй строке несколько раз, то правило замены определяется первым встреченным экземпляром. Если строка третьего аргумента длиннее, чем строка второго, лишние символы игнорируются.</P>

<BLOCKQUOTE><B>Замена:</B> Функция <B><A href="#function-translate">translate</A></B> не может обеспечить преобразование регистра для всех языков. Для преобразования регистра в будущих версии XPath могут появиться дополнительные функции.</BLOCKQUOTE>

<H3><A name=section-Boolean-Functions></A>4.3 Функции обработки булевых значений</H3>

<P><A name=function-boolean><B>Функция: </B><I>boolean</I> <B>boolean</B>(<I>object</I>)</A> </P>

<P>Функция <B><A href="#function-boolean">boolean</A></B> преобразует аргумент в булево значение следующим образом:</P>

<UL>

<LI><P>число преобразуется в true тогда и только тогда, когда оно не является ни NaN, ни положительным или отрицательным нулем</P>

<LI>
<P>набор узлов преобразуется в true тогда и только тогда, когда он непустой</P>

<LI><P>строка преобразуется true тогда и только тогда, когда она имеет ненулевую длину</P>


<LI><P>процедура преобразования в булево значение объекта, не относящегося в четырем основным типам, зависит от типа этого объекта</P></LI>

</UL>

<P><A name=function-not><B>Функция: </B><I>boolean</I> <B>not</B>(<I>boolean</I>)</A> </P>

<P>Функция <B><A href="#function-not">not</A></B> возвращает true тогда и только тогда, когда ее аргументом является false, и false в противном случае.</P>

<P><A name=function-true><B>Функция: </B><I>boolean</I> <B>true</B>()</A></P>

<P>Функция <B><A href="#function-true">true</A></B> возвращает true.</P>

<P><A name=function-false><B>Функция: </B><I>boolean</I> <B>false</B>()</A></P>

<P>Функция <B><A href="#function-false">false</A></B> возвращает false.</P>

<P><A name=function-lang><B>Функция: </B><I>boolean</I> <B>lang</B>(<I>string</I>)</A> </P>

<P>Функция <B><A href="#function-lang">lang</A></B> возвращает true или false в зависимости от того, является ли язык узла контекста, указываемый в атрибутах <CODE>xml:lang</CODE>, тем же самым языком (или подмножеством языка), что указан в строке атрибута. Язык узла контекста задается значением атрибута <CODE>xml:lang</CODE>, указанного в этом узле, либо, если сам узел контекста не имеет атрибута <CODE>xml:lang</CODE>, то значением атрибута <CODE>xml:lang</CODE> у его ближайшего предка, имеющего такой атрибут. Если требуемый атрибут не найден, функция <B><A href="#function-lang">lang</A></B> возвращает false. Если же атрибут найден, то  функция <B><A href="#function-lang">lang</A></B> возвращает true когда значение этого атрибута равно значению аргумента. При этом регистр игнорируется. Кроме того, если значение атрибута имеет суффикс, начинающийся с дефиса (<CODE>-</CODE>), то перед сравнением такой суффикс может быть отброшен. Например, вызов функции <CODE>lang("en")</CODE> возвращает true если узлом контекста является любой из пяти указанных элементов:</P>

<PRE>&lt;para xml:lang="en"/&gt;

&lt;div xml:lang="en"&gt;&lt;para/&gt;&lt;/div&gt;

&lt;para xml:lang="EN"/&gt;

&lt;para xml:lang="en-us"/&gt;</PRE>

<H3><A name=section-Number-Functions></A>4.4 Функции обработки чисел</H3>

<P><A name=function-number><B>Функция: </B><I>number</I> <B>number</B>(<I>object</I>?)</A> </P>


<P>Функция <B><A href="#function-number">number</A></B> преобразует свой аргумент в число следующим образом:</P>

<UL>

<LI><P>строка, образованная необязательным пробельным символом, за которым следует необязательный знак минус, <A href="#NT-Number">Number</A> и пробельный символ, преобразуется в число IEEE 754, ближайшее к математическому значению, представленному этой строкой (в соответствии с правилом округления IEEE 754). Любая другая строка преобразуется в NaN.</P>

<LI><P>булево значение true преобразуется в 1, булево значение false преобразуется в 0</P>

<LI><P>набор узлов сперва преобразуется в строку как при вызове функции <B><A href="#function-string">string</A></B>, а затем преобразуется по тому же алгоритму, что и строковый аргумент</P>

<LI><P>объект, не соответствующий ни одному из четырех базовых типов, преобразуется в число по алгоритму, специально задаваемому для этого типа</P></LI>

</UL>

<P>Если аргумент отсутствует, то по умолчанию берется набор, содержащий только узел контекста.</P>

<BLOCKQUOTE><B>Замечание:</B> Функция <B><A href="#function-number">number</A></B> не должна использоваться для преобразования числовых данных, встреченных в каком-либо элементе XML документа, если не известно, что элемент данного типа представляет числовые данные в независимом от языка формате (обычно перед показом пользователю такой элемент переводятся в формат, соответствующий языку). Кроме того, функция <B><A href="#function-number">number</A></B> не может использоваться, если независимый от языка формат элемента не соответствует синтаксису XPath для <A href="#NT-Number">Number</A>.</BLOCKQUOTE>


<P><A name=function-sum><B>Функция: </B><I>number</I> <B>sum</B>(<I>node-set</I>)</A> </P>

<P>Функция <B><A href="#function-sum">sum</A></B> возвращает сумму всех узлов из набора, указанного в аргументе. Перед суммированием <A href="#dt-string-value">строковые значения</A> узлов преобразуются в числа.</P>

<P><A name=function-floor><B>Функция: </B><I>number</I> 


<B>floor</B>(<I>number</I>)</A> </P>

<P>Функция <B><A href="#function-floor">floor</A></B> возвращает наибольшее число (ближайшее к положительной бесконечности), которое не превышает значение представленного аргумента и является целым.</P>

<P><A name=function-ceiling><B>Функция: </B><I>number</I> <B>ceiling</B>(<I>number</I>)</A> </P>


<P>Функция <B><A href="#function-ceiling">ceiling</A></B> возвращает наименьшее число (ближайшее в отрицательной бесконечности), которое не меньше значения представленного аргумента и является целым.</P>


<P><A name=function-round><B>Функция:</B> <I>number</I> <B>round</B>(<I>number</I>)</A> </P>

<P>Функция <B><A href="#function-round">round</A></B> возвращает целое число, ближайшее к значению аргумента. Если таких чисел два, то возвращается то из них, которое ближе к положительной бесконечности. Если аргументом является NaN, функция возвращает NaN. Если аргументом является положительная бесконечность, возвращается положительная бесконечность. Если аргументом является отрицательная бесконечность, возвращается отрицательная бесконечность. Если аргументом является положительный нуль, функция возвращает положительный нуль. Если аргументом является отрицательный нуль, функция возвращает отрицательный нуль. Если аргумент меньше нуля, но больше или равен -0.5, возвращается отрицательный нуль.</P>

<BLOCKQUOTE><B>Замечание:</B> В последних двух случаях вызов функции <B><A href="#function-round">round</A></B> имеет иной результат, чем добавление 0.5 и последующий вызов функции <B><A href="#function-floor">floor</A></B>.</BLOCKQUOTE>

<H2><A name=data-model></A>5 Модель данных</H2>

<P>XPath обрабатывает XML документ как древовидную структуру. В этой главе описывается, как именно XPath моделирует дерево XML документа. Указанная модель носит лишь концептуальный характер и не содержит указаний для какой-либо конкретной реализации. Взаимосвязь этой модели с XML Information Set <A href="#XINFO">[XML Infoset]</A> описывается в Приложении <A href="#infoset">[<B>B XML Information Set Mapping</B>]</A>.</P>

<P>XML документы, обрабатываемые XPath, должны отвечать требованиям Рекомендации XML Namespaces <A href="#XMLNAMES">[XML Names]</A>.</P>

<P>Дерево состоит из узлов. Узлы бывают семи типов:</P>

<UL>

<LI><P>корневые узлы</P>

<LI><P>узлы элементов</P>

<LI><P>узлы текста</P>

<LI><P>узлы атрибутов</P>

<LI><P>узлы пространства имен</P>

<LI><P>узлы инструкций обработки</P>

<LI><P>узлы комментариев</P></LI>

</UL>

<P><A name=dt-string-value></A>Для каждого типа узлов существует алгоритм определения <B>строкового значения</B> узла этого типа. Для некоторых типов узлов строковое значение является частью самого узла, для других типов узлов строковое значение вычисляется по строковому значению узлов - потомков.</P>

<BLOCKQUOTE><B>Замечание:</B> Для узлов элементов и корневых узлов строковое значение узла - это не та же самая строка, которую возвращает метод <CODE>nodeValue</CODE> модели DOM (см. <A href="#DOM">[DOM]</A>).</BLOCKQUOTE>

<P><A name=dt-expanded-name></A>Некоторые типы узлов имеют также <B>расширенное имя</B>, состоящее из двух частей: локальной части и URI пространства имен. Локальная часть - это строка, URI пространства имен - строка или null. В качестве URI пространства имен, указываемого в XML документе, может выступать ссылка URI, описанная в <A href="#RFC2396">[RFC2396]</A>. Это означает, что он может иметь идентификатор фрагмента и быть относительным. В процессе обработки пространства имен относительный URI должен преобразовываться в абсолютный - URI пространства имен для <A href="#dt-expanded-name">расширенного имени</A> узла в модели данных всегда должен стать абсолютным. Два <A href="#dt-expanded-name">расширенных имени</A> считаются идентичными, если они имеют одинаковую локальную часть и либо оба имеют нулевой URI пространства имен, либо имеют одинаковые ненулевые URI пространства имен.</P>

<P><A name=dt-document-order></A>Для всех узлов в документе определяется порядок, называемый <B>порядком появления в документе</B>. Он соответствует появлению узлов в XML представлении документа после расшифровки всех общих сущностей - точнее выражаясь, не самих узлов, а первых символов из XML представления соответствующего узла. Следовательно, корневой узел всегда будет первым узлом, а узлы элементов будут предшествовать своим непосредственным потомкам. Таким образом, порядок появления в документе упорядочивает узлы элементов согласно очередности появления в XML документе соответствующих открывающих тэгов (после подстановки всех сущностей). Считается, что в элементе узлы атрибутов и пространств имен всегда предшествуют непосредственным потомкам элемента. При этом узлы пространств имен предшествуют узлам атрибутов. Относительный порядок следования узлов пространства имен и относительный порядок следования узлов атрибутов зависят от реализации. <A name=dt-reverse-document-order></A><B> Обратный порядок появления в документе</B> - это порядок, обратный <A href="#dt-document-order">порядку появления в документе</A>.</P>

<P>Корневые узлы и узлы элементов имеют упорядоченный список узлов непосредственных потомков. Узлы не могут иметь совместных непосредственных потомков: если один узел отличается от другого, то ни один узел непосредственного потомка первого узла не может совпасть с каким-либо узлом непосредственного потомка другого узла. <A name=dt-parent></A>Каждый узел, за исключением корневого, имеет ровно одного <B>родителя</B>, который является либо узлом элемента, либо корневым узлом. Корневой узел и узел элемента являются родителями для каждого из своих непосредственных потомков.  <A name=dt-descendants></A><B>Потомки</B> узла - это непосредственные потомки данного узла и все потомки непосредственных потомков этого узла.</P>

<H3><A name=root-node></A>5.1 Корневой узел</H3>


<P>Корневой узел является корнем дерева документа. Корневой узел не может появляться нигде кроме как в корне дерева. Узел, соответствующий элементу документа, является непосредственным потомком корневого узла. Корневой узел имеет непосредственными потомками также узлы инструкций обработки, узлы комментариев для инструкций обработки и узлы комментариев, которые либо предшествуют, либо следуют за элементом документа.</P>

<P><A href="#dt-string-value">Строковое значение</A> корневого узла является объединением <A href="#dt-string-value">строковых значений</A> всех текстовых узлов, являющихся <A href="#dt-descendants">потомками</A> корневого узла, выстроенными согласно порядку появления в документе.</P>

<P>Корневой узел не имеет <A href="#dt-expanded-name">расширенного имени</A>.</P>


<H3><A name=element-nodes></A>5.2 Узлы элементов</H3>

<P>Для каждого элемента в документе создается узел элемента. Узел элемента имеет <A href="#dt-expanded-name">расширенное имя</A>, получаемое при обработке <A href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A> этого элемента, которое, согласно рекомендации XML Namespaces <A href="#XMLNAMES">[XML Names]</A>, указывается в соответствующем теге. Если <A href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A> не имеет префикса и нет пространства имен, используемого по умолчанию, то URI пространства имен для <A href="#dt-expanded-name">расширенного имени</A> данного элемента будет нулевым.</P>

<BLOCKQUOTE><B>Замечание:</B> Согласно нотации в Приложении A.3 документа <A href="#XMLNAMES">[XML Names]</A>, локальная часть расширенного имени соответствует атрибуту <CODE>type</CODE> в элементе <CODE>ExpEType</CODE>. URI пространства имен для расширенного имени соответствует атрибуту <CODE>ns</CODE> в элементе <CODE>ExpEType</CODE> и становится нулевым, если такой атрибут не был представлен.</BLOCKQUOTE>

<P>Непосредственными потомками узла элемента могут быть узлы элементов, узлы комментариев, узлы инструкций обработки и текстовые узлы, образующие его содержание. При этом обрабатываются ссылки на внутренние и внешние сущности. Выполняется подстановка для ссылок на символы.</P>

<P><A href="#dt-string-value">Строковое значение</A> узла элемента является объединением <A href="#dt-string-value">строковых значений</A> всех текстовых узлов, являющихся <A href="#dt-descendants">потомками</A> данного узла элемента и предварительно отсортированных согласно порядку появления в документе.</P>

<H4><A name=unique-id></A>5.2.1 Уникальные ID</H4>

<P>Узел элемента может иметь уникальный идентификатор (ID). Значение этого атрибута декларируется в DTD как тип <CODE>ID</CODE>. Никакие два элемента в пределах одного документа не могут иметь одинаковые уникальные идентификаторы. Если XML процессор сообщает о существовании в документе двух элементов, имеющих один и тот же уникальный идентификатор (а такое возможно только если этот документ недействителен), то из двух данных элементов тот, который встретился в документе позже, будет обрабатываться как не имеющий уникального идентификатора.</P>

<BLOCKQUOTE><B>Замечание:</B> Если документ не имеет DTD, то ни один из его элементов не будет иметь уникального идентификатора.</BLOCKQUOTE>

<H3><A name=attribute-nodes></A>5.3 Узлы атрибутов</H3>

<P>С каждым узлом элемента связан набор узлов атрибутов. При этом, хотя сам элемент является <A href="#dt-parent">родителем</A> каждого из этих узлов атрибутов, узел атрибута непосредственным потомком своего родительского элемента не является.</P>

<BLOCKQUOTE><B>Замечание:</B> В этом заключается отличие от модели DOM, где элемент, владеющий атрибутом, родителем этого атрибута не считается (см. <A href="#DOM">[DOM]</A>).</BLOCKQUOTE>

<P>Элементы не могут совместно использовать узлы атрибутов: Если один узел элемента отличается от другого, то ни один из узлов атрибутов, относящихся к первому узлу элемента, не может совпасть ни с одним узлом атрибута, относящимся ко второму узлу элемента.</P>

<BLOCKQUOTE><B>Замечание:</B> Оператор <CODE>=</CODE> проверяет, имеют ли два узла одно и то же значение, однако <I>не</I> проверяет, являются ли они одним и тем же узлом. Таким образом, атрибуты двух различных элементов можно сравнивать с помощью оператора <CODE>=</CODE>, даже несмотря на то, что они представлены различными узлами.</BLOCKQUOTE>

<P>Атрибут, подставляемый по умолчанию, обрабатывается точно так же, как атрибут, указанный явно. Если для данного типа элемента в DTD атрибут был декларирован со значением по умолчанию <CODE>#IMPLIED</CODE>, однако в элементе этот атрибут представлен не был, считается, что в наборе атрибутов указанного элемента нет узла для этого атрибута.</P>

<P>Некоторые атрибуты, такие как <CODE>xml:lang</CODE> и <CODE>xml:space</CODE>, имеют семантику, которая распространяется на все элементы, являющиеся потомками элемента с этим атрибутом (если затем семантика не была переопределена таким же атрибутом в другом элементе, являющемся его потомком). Однако это не накладывает ограничений на местоположение узлов атрибутов в дереве документа: любой элемент имеет узлы только тех атрибутов, которые либо были явно указаны в начальном тэге или тэге пустого элемента, относящихся в этому элементу, либо были явно декларированы в DTD со значением по умолчанию.</P>

<P>Узел атрибута имеет <A href="#dt-expanded-name">расширенное имя</A> и <A href="#dt-string-value">строковое значение</A>. <A href="#dt-expanded-name">Расширенное имя</A> получается при обработке <A href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A>, указанного в соответствующем тэге XML документа согласно Рекомендации XML Namespaces <A href="#XMLNAMES">[XML Names]</A>. Если <A href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A> атрибута не имеет префикса, URI пространства имен для имени атрибута будет нулевым.</P>

<BLOCKQUOTE><B>Замечание:</B> Согласно нотации в Приложении A.3 документа <A href="#XMLNAMES">[XML Names]</A>, локальная часть расширенного имени соответствует атрибуту <CODE>name</CODE> элемента <CODE>ExpAName</CODE>, URI пространства имен расширенного имени соответствует атрибуту <CODE>ns</CODE> элемента <CODE>ExpAName</CODE> и будет нулевым, если атрибут <CODE>ns</CODE> в элементе <CODE>ExpAName</CODE> опущен.</BLOCKQUOTE>

<P>Узел атрибута имеет <A href="#dt-string-value">строковое значение</A>. <A href="#dt-string-value">Строковое значение</A> нормализовано в соответствии с Рекомендацией XML <A href="#XML">[XML]</A>. Не предусмотрено специальной обработки для атрибута, чье нормализованное значение становится строкой нулевой длины - результатом будет узел атрибута, чьим <A href="#dt-string-value">строковым значением</A> становится строка нулевой длины.</P>

<BLOCKQUOTE><B>Замечание:</B> во внешнем DTD или внешней сущности параметра могут декларироваться атрибуты по умолчанию. Согласно рекомендации XML, если процессор XML не является проверяющим, он не обязан читать внешние DTD и внешние параметры. Соответственно, с некоторыми непроверяющими XML процессорами могут не работать стили и другой функционал, предполагающий, что дерево XPath содержит значения атрибутов по умолчанию, декларированные во внешнем DTD или сущности параметра.</BLOCKQUOTE>


<P>Для атрибутов, декларирующих пространства имен, соответствующих узлов атрибутов не предусмотрено (см. <A href="#XMLNAMES">[XML Names]</A>).</P>

<H3><A name=namespace-nodes></A>5.4 Узлы пространства имен</H3>

<P>С каждым элементом связан набор узлов пространства имен: по одному на каждый новый префикс пространства имен, появившийся в области видимости этого элемента, (включая и перфикс <CODE>xml</CODE>, явным образом декларированный Рекомендацией XML Namespaces <A href="#XMLNAMES">[XML Names]</A>), и еще один узел для пространства имен по умолчанию, если таковое имеется в области видимости элемента. Данный элемент является <A href="#dt-parent">родителем</A> каждого такого узла пространства имен, однако узел пространства имен непосредственным потомком соответствующего элемента родителя не становится. Элементы не могут совместно использовать узлы пространства имен: если один узел элемента отличается от другого узла элемента, то ни один из узлов пространства имен, принадлежащих одному элементу, не может совпасть с узлом пространства имен, относящихся ко второму узлу элемента. Это означает, что элемент получит узел пространства имен:</P>

<UL>

<LI><P>для каждого атрибута элемента, чье имя начинается с <CODE>xmlns:</CODE>,</P>

<LI><P>для каждого атрибута в элементе-предке, чье имя начинается с <CODE>xmlns:</CODE>, при условии что данный префикс не был затем переопределен самим элементом или его более близким предком,</P>

<LI><P>для атрибута <CODE>xmlns</CODE>, если сам элемент или какой-либо из его предков имеют атрибут <CODE>xmlns</CODE> и при этом атрибут <CODE>xmlns</CODE> самого ближайшего из таких элементов не является пустым</P>

<BLOCKQUOTE><B>Замечание:</B> Атрибут <CODE>xmlns=""</CODE> отменяет декларацию пространства имен по умолчанию (см. <A href="#XMLNAMES">[XML Names]</A>).</BLOCKQUOTE></LI>

</UL>

<P>Узел пространства имен имеет <A href="#dt-expanded-name">расширенное имя</A>, локальная часть которого является префиксом пространства имен (она является пустой, если данный узел относится к пространству имен по умолчанию), а идентификатор URI пространства имен всегда нулевой.</P>

<P><A href="#dt-string-value">Строковое значение</A> узла пространства имен - это URI пространства имен, связанного с данным префиксом пространства имен. Если данный URI окажется относительным, он должен обрабатываться точно так же, как URI пространства имен в <A href="#dt-expanded-name">расширенном имени</A>.</P>

<H3><A name=section-Processing-Instruction-Nodes></A>5.5 Узлы инструкций обработки</H3>

<P>Для каждой инструкции обработки создается соответствующий узел. Исключение составляют инструкции обработки, помещенные в декларацию типа документа.</P>

<P>Инструкция обработки имеет <A href="#dt-expanded-name">расширенное имя</A>, в котором локальная часть - это адресат инструкции обработки, а URI пространства имен является нулевым. <A href="#dt-string-value">Строковое значение</A> узла инструкции обработки - это та часть инструкции обработки, которая следует за адресатом и возможным пробельным символом. В состав строкового значения также не попадает завершающая комбинация <CODE>?&gt;</CODE>.</P>

<BLOCKQUOTE><B>Замечание:</B> Декларация XML инструкцией обработки не является. Соответственно, ни один из узлов инструкции обработки не может соответствовать декларации XML.</BLOCKQUOTE>

<H3><A name=section-Comment-Nodes></A>5.6 Узлы комментариев</H3>

<P>Для каждого комментария создается соответствующий узел. Исключение составляют комментарии, расположенные в декларации типа документа.</P>

<P><A href="#dt-string-value">Строковым значением</A> комментария является содержимое этого комментария за исключением открывающей <CODE>&lt;!--</CODE> и закрывающей <CODE>--&gt;</CODE> комбинаций.</P>

<P>Узлы комментария <A href="#dt-expanded-name">расширенного имени</A> не имеют.</P>

<H3><A name=section-Text-Nodes></A>5.7 Текстовые узлы</H3>

<P>Символьные данные группируются в узлы текста. В каждый из таких узлов помещается столько символьных данных, сколько возможно: с текстовым узлом ни до, ни после не может соседствовать какой-либо другой текстовый узел, имеющий того же родителя. <A href="#dt-string-value">Строковым значением</A> текстового узла являются эти самые текстовые данные. Текстовый узел всегда содержит по крайней мере один символ данных.</P>

<P>Все символы в секции CDATA обрабатываются как символьные данные. Таким образом, запись <CODE>&lt;![CDATA[&lt;]]&gt;</CODE> в исходном документе будет обрабатываться так же, как и <CODE>&amp;lt;</CODE>. Оба варианта будут иметь результатом один символ <CODE>&lt;</CODE> в текстовом узле дерева документа. Таким образом, секция CDATA обрабатывается так, словно были удалены комбинации <CODE>&lt;![CDATA[</CODE> и <CODE>]]&gt;</CODE>, а все символы <CODE>&lt;</CODE> и <CODE>&amp;</CODE> были заменены на <CODE>&amp;lt;</CODE> и <CODE>&amp;amp;</CODE> соответственно.</P>

<BLOCKQUOTE><B>Замечание:</B> Если текстовый узел, содержащий символ <CODE>&lt;</CODE>, записывается как XML, сам символ <CODE>&lt;</CODE> должен маскироваться, например, с помощью <CODE>&amp;lt;</CODE> или помещением в секцию CDATA.</BLOCKQUOTE>

<P>Символьные данные в комментариях, инструкциях обработки и значениях атрибутов текстовых узлов не образуют. Концы строк во внешних сущностях нормализуются в #xA в соответствии с Рекомендацией XML <A href="#XML">[XML]</A>.</P>

<P>Текстовый узел <A href="#dt-expanded-name">расширенного имени</A> не имеет.</P>

<H2><A name=section-Conformance></A>6 Соответствие</H2>

<P>XPath изначально создавался как компонент для использования в других спецификациях. Поэтому XPath обращается к использующим его спецификациям (таким как <A href="#XPTR">[XPointer]</A> или <A href="#XSLT">[XSLT]</A>) за получением критериев проверки реализаций XPath, вместо того чтобы самому формулировать критерии оценки независимых реализаций XPath.</P>

<HR title="Separator from footer">

<H2><A name=section-References></A>A Ссылки</H2>

<H3><A name=section-Normative-References></A>A.1 Нормативные ссылки</H3>

<DL>

<DT><A name=IEEE754>IEEE 754</A> 


<DD>Institute of Electrical and Electronics Engineers. <I>IEEE Standard for Binary Floating-Point Arithmetic</I>. ANSI/IEEE Std 754-1985. 


<DT><A name=RFC2396>RFC2396</A> 

<DD>T. Berners-Lee, R. Fielding, and L. Masinter. <I>Uniform Resource Identifiers (URI): Generic Syntax</I>. IETF RFC 2396. См. <A href="http://www.ietf.org/rfc/rfc2396.txt">http://www.ietf.org/rfc/rfc2396.txt</A>. 

<DT><A name=XML>XML</A> 

<DD>World Wide Web Consortium. <I>Extensible Markup Language (XML) 1.0.</I> W3C Recommendation. См. <A href="http://www.w3.org/TR/1998/REC-xml-19980210">http://www.w3.org/TR/1998/REC-xml-19980210</A> 

<DT><A name=XMLNAMES>XML Names</A> 

<DD>World Wide Web Consortium. <I>Namespaces in XML.</I> W3C Recommendation. См. <A href="http://www.w3.org/TR/REC-xml-names">http://www.w3.org/TR/REC-xml-names</A> </DD>

</DL>

<H3><A name=section-Other-References></A>A.2 Остальные ссылки</H3>

<DL>

<DT><A name=CHARMOD>Character Model</A> 

<DD>World Wide Web Consortium. <I>Character Model for the World Wide Web.</I> Рабочий проект W3C. См. <A href="http://www.w3.org/TR/WD-charmod">http://www.w3.org/TR/WD-charmod</A> 

<DT><A name=DOM>DOM</A> 

<DD>World Wide Web Consortium. <I>Document Object Model (DOM) Level 1 
Specification.</I> Рекомендация W3C. См. <A href="http://www.w3.org/TR/REC-DOM-Level-1">http://www.w3.org/TR/REC-DOM-Level-1</A> 

<DT><A name=JLS>JLS</A> 

<DD>J. Gosling, B. Joy, and G. Steele. <I>The Java Language Specification</I>. См. <A href="http://java.sun.com/docs/books/jls/index.html">http://java.sun.com/docs/books/jls/index.html</A>. 


<DT><A name=ISO10646>ISO/IEC 10646</A> 

<DD>ISO (International Organization for Standardization). <I>ISO/IEC 10646-1:1993, Information technology -- Universal Multiple-Octet Coded Character Set (UCS) -- Part 1: Architecture and Basic Multilingual Plane</I>. Международный стандарт. См. <A href="http://www.iso.ch/cate/d18741.html">http://www.iso.ch/cate/d18741.html</A>. 


<DT><A name=TEI>TEI</A> 

<DD>C.M. Sperberg-McQueen, L. Burnard <I>Guidelines for Electronic Text Encoding and Interchange</I>. См. <A href="http://etext.virginia.edu/TEI.html">http://etext.virginia.edu/TEI.html</A>. 

<DT><A name=UNICODE>Unicode</A> 

<DD>Unicode Consortium. <I>The Unicode Standard</I>. См. <A href="http://www.unicode.org/unicode/standard/standard.html">http://www.unicode.org/unicode/standard/standard.html</A>. 


<DT><A name=XINFO>XML Infoset</A> 

<DD>World Wide Web Consortium. <I>XML Information Set.</I> Рабочий проект W3C. См. <A href="http://www.w3.org/TR/xml-infoset">http://www.w3.org/TR/xml-infoset</A> 

<DT><A name=XPTR>XPointer</A> 

<DD>World Wide Web Consortium. <I>XML Pointer Language (XPointer).</I> Рабочий проект W3C. См. <A 

href="http://www.w3.org/TR/WD-xptr">http://www.w3.org/TR/WD-xptr</A> 

<DT><A name=XQL>XQL</A> 

<DD>J. Robie, J. Lapp, D. Schach. <I>XML Query Language (XQL)</I>. См. <A href="http://www.w3.org/TandS/QL/QL98/pp/xql.html">http://www.w3.org/TandS/QL/QL98/pp/xql.html</A> 

<DT><A name=XSLT>XSLT</A> 

<DD>World Wide Web Consortium. <I>XSL Transformations (XSLT).</I> Рекомендация W3C. См. <A href="http://www.w3.org/TR/xslt">http://www.w3.org/TR/xslt</A> </DD>

</DL>



<H2><A name=infoset></A>B Отображение XML Information Set (Обсуждение спецификации)</H2>

<P>Узлы модели данных XPath могут быть получены из информационных элементов в XML Information Set <A href="#XINFO">[XML Infoset]</A> следующим образом:</P>

<BLOCKQUOTE><B>Замечание:</B> Следующая версия рабочего проекта XML Information Set, которая сменит версию от 17 мая, была близка к завершению в то время, когда была завершена подготовка текущей версии XPath. Предполагалось, что она будет реализована одновременно или чуть позже данной версии XPath. Порядок отображения дается для этой новой версии рабочего проекта XML Information Set. А пока новая версия XML Information Set еще не реализована, члены W3C могут сверяться с внутренней версией соответствующей рабочей группы по адресу <A href="http://www.w3.org/XML/Group/1999/09/WD-xml-infoset-19990915.html">http://www.w3.org/XML/Group/1999/09/WD-xml-infoset-19990915.html</A> (<A href="http://cgi.w3.org/MemberAccess/">только для членов</A>).

</BLOCKQUOTE>

<UL>

<LI><P>Корневой узел получается из информационного элемента document. Непосредственный потомок корневого узла получается из свойств <I>children</I> и <I>children - comments</I>.</P>

<LI><P>Узел элемента получается из информационного элемента element. Непосредственный потомок узла элемента получается из свойств <I>children</I> и <I>children - comments</I>. Атрибуты узла элемента получаются из свойства <I>attributes</I>. Пространства имен для узла элемента получаются из свойства <I>in-scope namespaces</I>. Локальная часть для <A href="#dt-expanded-name">расширенного имени</A> узла элемента получается из свойства <I>local name</I>. URI пространства имен для <A href="#dt-expanded-name">расширенного имени</A> узла элемента получается из свойства <I>namespace URI</I>. Уникальный идентификатор узла элемента (ID) получается из свойства <I>children</I> информационного элемента атрибута в свойстве <I>attributes</I>, в котором имеется свойство <I>attribute type</I>, равное <CODE>ID</CODE>.</P>

<LI><P>Узел атрибута получается из информационного элемента attribute. Локальная часть <A href="#dt-expanded-name">расширенного имени</A> узла атрибута получается из свойства <I>local name</I>. URI пространства имен для <A href="#dt-expanded-name">расширенного имени</A> узла атрибута получается из свойства <I>namespace URI</I>. <A href="#dt-string-value">Строковое значение</A> узла получается объединением свойств <I>character code</I> всех членов свойства <I>children</I>.</P>

<LI><P>Текстовый узел формируется последовательностью из одного или нескольких следующих друг за другом информационных элементов character. <A href="#dt-string-value">Строковое значение</A> узла получается объединением свойств <I>character code</I> всех информационных элементов character.</P>

<LI><P>Узел инструкции обработки получается из информационного элемента processing instruction. Локальная часть <A href="#dt-expanded-name">расширенного имени</A> этого узла происходит из свойства <I>target</I>. (URI пространства имен для <A href="#dt-expanded-name">расширенного имени</A> этого узла является нулевым.) <A href="#dt-string-value">Строковое значение</A> узла получается из свойства <I>content</I>. Для элементов processing instruction, являющихся непосредственными потомками информационного элемента document type declaration, узлы processing instruction не создаются.</P>

<LI><P>Узел комментария получается из информационного элемента comment. <A href="#dt-string-value">Строковое значение</A> узла происходит из свойства <I>content</I>. Для информационных элементов comment, являющихся непосредственными потомками информационного элемента document type declaration, узлы комментариев не создаются.</P>

<LI><P>Узлы пространства имен создаются из информационных элементов namespace declaration. Локальная часть <A href="#dt-expanded-name">расширенного имени</A> такого узла создается из свойства <I>prefix</I>. (URI пространства имен для <A href="#dt-expanded-name">расширенного имени</A> такого узла является нулевым.) <A href="#dt-string-value">Строковое значение</A> узла происходит из свойства <I>namespace URI</I>.</P></LI>

</UL>


<table width="100%" cellpadding="0"><tr><td bgcolor="#E8E8E8">

<DIV class=div1>

<H2 style="BACKGROUND: #E8E8E8;"><A name=dictionary></A>C Словарь (Обсуждение спецификации)</H2>


<P>При переводе спецификации на русский язык для ряда терминов был выбран следующий вариант перевода.</P>

<P>

child - непосредственный потомок<BR>

context position - положение в контексте<BR>

context node - узел контекста<BR>

descendant - потомок<BR>

document element - элемент документа<BR>

forward axis - прямая ось<BR>

information item - информационный элемент (в XML Information Set)<BR>

location path - путь адресации<BR>

location step - шаг адресации<BR>


node-set - набор, множество узлов<BR>

node-test - правило проверки узлов<BR>

non-terminal - незавершенный конструктив<BR>

principal node type - основной тип узлов<BR>


processing instruction  - инструкция обработки (XML)<BR>

production - сценарий<BR>

proximity position - положение близости<BR>

reverse axis - обратная ось<BR>

symbol - грамматическая конструкция (XML)<BR>

token - лексема<BR>

validating processor - проверяющий процессор<BR>

variable binding - привязка переменной контекста<BR>

</P>

<P>Если у вас возникли какие-либо замечания, мы будем рады их получить по адресу <A href="mailto:radik_u@mail.ru">radik_u@mail.ru</A>.</P>

</DIV>
</td></tr></table>
<!-- end main text -->

</TD></TR></TABLE>
</TD></TR></TABLE>

</td>
<!-- <td width=6>&nbsp;</td> -->
</tr>
  <tr>
<!--     <td width=6 height=6><img src=/p.gif width=6 height=6></td> -->
    <td height=6><img src=/p.gif width=6 height=6></td>
<!--     <td width=6 height=6><img src=/p.gif width=6 height=6></td> -->
  </tr>
</table>

</td>
<td width=6 valign=top><img src="/images/header_fon2.gif" width=6 height="40"></td>
</tr></table>

<table width=100% border=0 cellspacing=0 cellpadding=0>
	<tr>
	<td width=6 height="20"><img src=/p.gif width=6 height="20"></td>
	<td height="20">
	<table width=100% border=0 cellspacing=0 cellpadding=0><tr>
	<td background="/images/rol3l_headfon.gif" width="81"><a href="/index.htm"><img src="/images/rol3l_rollogo2.gif" width=100 height="20" border=0 alt="ROL"></a></td>
	<td background="/images/rol3l_headfon.gif" align=right>
		<table width=100% border=0 cellspacing=0 cellpadding=0><tr><td align=center background=/p.gif>
			<table border=0 cellspacing=0 cellpadding=0 width="600" align=center><tr>
			<td width="79"><a href=/map class="smenu">Карта сайта</a></td>
			<td width="89"><a href=http://omen.rol.ru class="smenu">Развлечения</a></td>
			<td width="64"><a href="http://www.rol.ru" class="smenu">Новости</a></td>
			<td width="50"><a href=http://www.aport.ru class="smenu">Поиск</a></td>
			<td width="43"><a href=http://ag.ru class="smenu">Игры</a></td>
			<td width="71"><a href=http://omen.ru/LOVE.HTM class="smenu">Знакомства</a></td>
			<td width="79"><a href="http://referat.rol.ru" class="smenu">Рефераты</a></td>
			<td nowrap width="125"><a href=http://voffice.rol.ru class="smenu">Личный кабинет</a></td>
			</tr></table>
			</td><td width="16" align=right><img src="/images/rol3l_headr.gif" width="16" height="20"></td>
		</tr></table>
	</td></tr></table>
</td><td width=6 height="20"><img src=/p.gif width=6 height="20"></td>
</tr><tr>
<td width=6 height=3><img src=/p.gif width=6 height=3></td>
<td height=3><img src=/p.gif width=6 height=3></td>
<td width=6 height=3><img src=/p.gif width=6 height=3></td>
</tr><tr>
<td width=6 valign=top><img src=/p.gif width=6 height=3></td><td valign=top>
	<table id=footer width=100% cellpadding=0 cellspacing=0 border=0 align=center>		<tr>
		<td width=150 align=right valign=top>
			<table cellpadding=0 cellspacing=0 border=0><tr>
			<td>

<a href="http://top100.rambler.ru/top100/"><img src="http://top100-images.rambler.ru/top100/banner-88x31-rambler-gray2.gif" alt="Rambler's Top100" width=88 height=31 border=0></a>
</td>
			<td>

<!-- SpyLOG f:0111 -->

<script language="javascript"><!--

Mu="u1872.15.spylog.com";Md=document;Mnv=navigator;Mp=1;

Mn=(Mnv.appName.substring(0,2)=="Mi")?0:1;Mrn=Math.random();

Mt=(new Date()).getTimezoneOffset();

Mz="p="+Mp+"&rn="+Mrn+"&t="+Mt;

My="";

My+="<a href='http://"+Mu+"/cnt?cid=187215&f=3&p="+Mp+"&rn="+Mrn+"' target=_blank>";

My+="<img src='http://"+Mu+"/cnt?cid=187215&"+Mz+"&r="+escape(Md.referrer)+"&pg="+escape(window.location.href)+"' border=0 width=88 height=31 alt='SpyLOG' hspace='5' vspace='4'>";

My+="</a>";Md.write(My);//--></script><noscript>

<a href="http://u1872.15.spylog.com/cnt?cid=187215&f=3&p=1" target=_blank>

<img src="http://u1872.15.spylog.com/cnt?cid=187215&p=1" alt='SpyLOG' border='0' width=88 height=31 hspace=5 vspace=4>

</a></noscript>

<!-- SpyLOG -->


<!-- SpyLOG -->



</td>
			</tr></table>
		</td><td valign=top>
			<table width=100% cellpadding=0 cellspacing=0 border=0 align=center><tr>
			<td width=7 valign=top align=right><img src="/images/about_left.gif" width=7 border=0></td>
			<td width=83 background="/images/about_bg.gif"><img height=4 src=/p.gif width=20><a href="http://www.goldentelecom.ru" target="_top"><img alt="Голден Телеком" src="http://www.rol.ru/images/gt_logo.gif" border=0 ></A><br>
</td>
			<td width=13 background="/images/about_bg.gif"><img src=/p.gif width=13 height=8></td>
			<td background="/images/about_bg.gif" class=logotext>&copy; 1995-2004 Golden Telecom. Все права защищены. Предоставляется в соответствии с <a href="http://services.rol.ru/rus/terms.htm" class=logotext target="_top"><font color="#7D7D7D">"Соглашением об использовании"</font></a>.
</td>
			<td width=7 valign=top><img src="/images/about_right.gif" width=7 border=0></td>
			</tr></table>
		</td><td width=20 rowspan=2>&nbsp;</td>
	</tr></table>
	<img src=/p.gif width=6 height=3>
	</td><td width=6><img src=/p.gif width=6 height=3></td>
</tr></table>

<!-- AdRiver code START Type: javascript Site: ??? SZ: SecondPages PZ: 0 BN: 0-->
<script language="JavaScript"><!--
var RndNum4NoCash = Math.round(Math.random() * 1000000000);
document.write('<script language="JavaScript" src="http://ad.adriver.ru/cgi-bin/erle.cgi?sid=34963&sz=SecondPages&target=blank&bt=16&pz=0&rnd=' + RndNum4NoCash + '"><\/script>');
//--></script>
<!-- AdRiver code END -->



</body>
</html>
